<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Stock Farmer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
      }
      body {
        display: flex;
        flex-direction: column;
        background-color: #000;
      }
      .canvas-wrapper {
        flex: 1 1 auto;
        position: relative;
        overflow: hidden;
      }
      #gridCanvas {
        width: 100%;
        height: 100%;
        display: block;
        touch-action: none;
        background-color: #000;
      }
    </style>
  </head>
  <body class="bg-black text-white">
    <nav class="bg-neutral-900 text-white">
      <div class="flex items-center px-4 py-2 relative">
        <a class="text-sm font-semibold whitespace-nowrap" href="#">
          Stock Farmer
        </a>

        <div
          id="currentSelection"
          class="absolute left-1/2 -translate-x-1/2 text-[11px] font-mono text-neutral-300 whitespace-nowrap overflow-hidden text-ellipsis opacity-0 transition-opacity"
        ></div>

        <div class="ml-auto flex items-center gap-2">
          <div
            id="totalDisplay"
            class="text-xs font-mono px-2 py-1 rounded bg-neutral-800"
          >
            $0.00
          </div>
          <button
            id="navToggle"
            class="inline-flex items-center justify-center p-2 rounded-md border border-gray-500 hover:bg-neutral-800 focus:outline-none"
            type="button"
            aria-controls="navOffcanvas"
            aria-expanded="false"
          >
            <span class="sr-only">Open controls</span>
            <svg class="h-4 w-4" viewBox="0 0 20 20" fill="none">
              <path
                d="M3 5h14M3 10h14M3 15h14"
                stroke="currentColor"
                stroke-width="1.6"
                stroke-linecap="round"
              />
            </svg>
          </button>
        </div>
      </div>
    </nav>

    <div id="navOverlay" class="fixed inset-0 bg-black/50 hidden z-30"></div>

    <div
      id="navOffcanvas"
      class="fixed inset-y-0 right-0 w-64 bg-neutral-900 text-white shadow-xl transform translate-x-full transition-transform duration-200 z-40 flex flex-col"
    >
      <div
        class="flex items-center justify-between px-4 py-3 border-b border-neutral-700"
      >
        <h5 class="text-sm font-semibold" id="navOffcanvasLabel">Controls</h5>
        <button
          id="navClose"
          class="p-1 rounded-md hover:bg-neutral-800 focus:outline-none"
        >
          <span class="sr-only">Close</span>
          <svg
            class="h-4 w-4"
            viewBox="0 0 20 20"
            fill="none"
            aria-hidden="true"
          >
            <path
              d="M5 5l10 10M15 5L5 15"
              stroke="currentColor"
              stroke-width="1.6"
              stroke-linecap="round"
            />
          </svg>
        </button>
      </div>
      <div class="flex-1 p-4 text-xs text-neutral-300 space-y-4">
        <div>
          <p class="mb-2 font-medium text-neutral-200">Crop</p>
          <div id="cropGrid" class="grid grid-cols-2 gap-2"></div>
        </div>

        <div>
          <p class="mb-2 font-medium text-neutral-200">Stock</p>
          <div id="stockGrid" class="grid grid-cols-3 gap-2"></div>
        </div>

        <button
          class="w-full border border-gray-500 text-xs px-3 py-2 rounded-md hover:bg-neutral-800 flex items-center justify-center text-center"
          id="recenterBtn"
        >
          Recenter view
        </button>
      </div>
    </div>

    <div class="canvas-wrapper">
      <canvas id="gridCanvas"></canvas>
    </div>

    <script>
      (function () {
        const canvas = document.getElementById("gridCanvas");
        const ctx = canvas.getContext("2d");

        const GRID_COLS = 100;
        const GRID_ROWS = 100;

        let tileSize = 100;
        const VISIBLE_ROWS_AT_START = 3;

        let offsetX = 0;
        let offsetY = 0;
        let scale = 1;
        let defaultScale = 1;
        const MIN_SCALE = 0.05;
        const MAX_SCALE = 3;

        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let dragOffsetStartX = 0;
        let dragOffsetStartY = 0;

        const activePointers = new Map();
        let isPinching = false;
        let pinchStartDistance = 0;
        let pinchStartScale = 1;
        let pinchCenterX = 0;
        let pinchCenterY = 0;

        let tapStart = null;

        let needsRender = true;
        let firstResizeDone = false;

        let totalMoney = 0;
        const totalDisplay = document.getElementById("totalDisplay");
        const currentSelectionEl = document.getElementById("currentSelection");

        const crops = {
          wheat: {
            id: "wheat",
            name: "Wheat",
            growMinutes: 1,
            baseValue: 1,
            unlocked: true,
            unlockCost: 0,
            images: [],
          },
          carrot: {
            id: "carrot",
            name: "Carrot",
            growMinutes: 5,
            baseValue: 5,
            unlocked: false,
            unlockCost: 10,
            images: [],
          },
          potato: {
            id: "potato",
            name: "Potato",
            growMinutes: 10,
            baseValue: 10,
            unlocked: false,
            unlockCost: 25,
            images: [],
          },
        };

        function loadCropImages(crop) {
          crop.growTimeMs = crop.growMinutes * 60 * 1000;
          crop.images = Array.from({ length: 4 }, (_, i) => {
            const img = new Image();
            img.src = `images/${crop.id}/${crop.id}-phase-${i + 1}.png`;
            img.onload = () => (needsRender = true);
            return img;
          });
        }

        Object.values(crops).forEach(loadCropImages);

        const stocks = {
          SP500: { symbol: "SP500", name: "S&P 500", price: 100 },
          AMZN: { symbol: "AMZN", name: "AMZN", price: 100 },
          TSLA: { symbol: "TSLA", name: "TSLA", price: 100 },
        };

        let selectedCropKey = "wheat";
        let previousCropKey = "wheat";
        let selectedStockKey = "SP500";

        const plots = new Map();

        const defaultFilled = ["49,49", "49,50", "50,49", "50,50"];
        const filled = new Set(defaultFilled);

        const SAVE_KEY = "stockFarmerState";

        function saveState() {
          const data = {
            totalMoney,
            filled: Array.from(filled),
            plots: Array.from(plots.entries()),
            selectedCropKey,
            previousCropKey,
            selectedStockKey,
            cropsUnlocked: Object.fromEntries(
              Object.entries(crops).map(([id, c]) => [id, c.unlocked])
            ),
          };
          try {
            localStorage.setItem(SAVE_KEY, JSON.stringify(data));
          } catch (err) {
            console.error("Failed to save state", err);
          }
        }

        function loadState() {
          let raw;
          try {
            raw = localStorage.getItem(SAVE_KEY);
          } catch (err) {
            console.error("Failed to read state", err);
            return;
          }
          if (!raw) return;

          try {
            const data = JSON.parse(raw);

            if (typeof data.totalMoney === "number") {
              totalMoney = data.totalMoney;
            }

            if (Array.isArray(data.filled)) {
              filled.clear();
              data.filled.forEach((k) => filled.add(k));
            }

            if (Array.isArray(data.plots)) {
              plots.clear();
              data.plots.forEach(([key, value]) => {
                plots.set(key, value);
              });
            }

            if (data.cropsUnlocked) {
              Object.entries(data.cropsUnlocked).forEach(([id, unlocked]) => {
                if (crops[id]) crops[id].unlocked = !!unlocked;
              });
            }

            if (data.selectedCropKey && crops[data.selectedCropKey]) {
              selectedCropKey = data.selectedCropKey;
              previousCropKey = data.previousCropKey || selectedCropKey;
            }

            if (data.selectedStockKey && stocks[data.selectedStockKey]) {
              selectedStockKey = data.selectedStockKey;
            }

            needsRender = true;
          } catch (err) {
            console.error("State load failed", err);
          }
        }

        loadState();

        const dirtImg = new Image();
        let dirtLoaded = false;
        dirtImg.src = "images/dirt.jpg";
        dirtImg.onload = () => {
          dirtLoaded = true;
          needsRender = true;
        };

        const grassImg = new Image();
        let grassLoaded = false;
        grassImg.src = "images/grass.jpg";
        grassImg.onload = () => {
          grassLoaded = true;
          needsRender = true;
        };

        function updateTotalDisplay() {
          const text = "$" + totalMoney.toFixed(2);
          if (totalDisplay) totalDisplay.textContent = text;
        }

        function updateCurrentSelectionLabel() {
          if (!currentSelectionEl) return;
          const crop = crops[selectedCropKey];
          const stock = stocks[selectedStockKey];

          if (!crop || !stock) {
            currentSelectionEl.innerHTML = "";
            currentSelectionEl.classList.add("opacity-0");
            return;
          }

          const cropBubbleDesktop =
            '<span class="inline-flex items-center px-2 py-0.5 rounded bg-neutral-800 text-neutral-100 mx-0.5">' +
            crop.name +
            "</span>";
          const stockBubbleDesktop =
            '<span class="inline-flex items-center px-2 py-0.5 rounded bg-neutral-800 text-neutral-100 mx-0.5">' +
            stock.name +
            "</span>";

          const cropBubbleMobile =
            '<span class="inline-flex items-center px-2 py-0.5 rounded bg-neutral-800 text-neutral-100 mx-0.5">' +
            crop.name +
            "</span>";
          const stockBubbleMobile =
            '<span class="inline-flex items-center px-2 py-0.5 rounded bg-neutral-800 text-neutral-100 mx-0.5">' +
            stock.symbol +
            "</span>";

          currentSelectionEl.innerHTML =
            '<span class="hidden sm:inline">' +
            "Currently planting " +
            cropBubbleDesktop +
            " tracking " +
            stockBubbleDesktop +
            "</span>" +
            '<span class="inline sm:hidden">' +
            cropBubbleMobile +
            " / " +
            stockBubbleMobile +
            "</span>";

          currentSelectionEl.classList.remove("opacity-0");
        }

        function centerView() {
          const rect = canvas.getBoundingClientRect();
          const worldWidth = GRID_COLS * tileSize;
          const worldHeight = GRID_ROWS * tileSize;
          const canvasWidth = rect.width;
          const canvasHeight = rect.height;
          const worldCenterX = worldWidth / 2;
          const worldCenterY = worldHeight / 2;
          const canvasCenterX = canvasWidth / 2;
          const canvasCenterY = canvasHeight / 2;

          offsetX = canvasCenterX - worldCenterX * scale;
          offsetY = canvasCenterY - worldCenterY * scale;

          needsRender = true;
        }

        function resizeCanvas() {
          const rect = canvas.getBoundingClientRect();
          const dpr = window.devicePixelRatio || 1;

          canvas.width = rect.width * dpr;
          canvas.height = rect.height * dpr;
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

          const scaleFromHeight =
            rect.height / (VISIBLE_ROWS_AT_START * tileSize);
          const scaleFromWidth =
            rect.width / (VISIBLE_ROWS_AT_START * tileSize);
          const initialScale = Math.min(scaleFromHeight, scaleFromWidth);

          if (!firstResizeDone) {
            scale = initialScale;
            defaultScale = initialScale;
            firstResizeDone = true;
          }

          centerView();
        }

        function clampScale(s) {
          return Math.min(MAX_SCALE, Math.max(MIN_SCALE, s));
        }

        function zoomAt(factor, cx, cy) {
          const newScale = clampScale(scale * factor);
          const k = newScale / scale;
          offsetX = cx - (cx - offsetX) * k;
          offsetY = cy - (cy - offsetY) * k;
          scale = newScale;
          needsRender = true;
        }

        function render() {
          if (!needsRender) return;
          needsRender = false;

          const width = canvas.clientWidth;
          const height = canvas.clientHeight;

          ctx.clearRect(0, 0, width, height);

          if (!dirtLoaded || !grassLoaded) return;

          const worldLeft = -offsetX / scale;
          const worldRight = (width - offsetX) / scale;
          const worldTop = -offsetY / scale;
          const worldBottom = (height - offsetY) / scale;

          const startCol = Math.max(0, Math.floor(worldLeft / tileSize));
          const endCol = Math.min(GRID_COLS, Math.ceil(worldRight / tileSize));
          const startRow = Math.max(0, Math.floor(worldTop / tileSize));
          const endRow = Math.min(GRID_ROWS, Math.ceil(worldBottom / tileSize));

          const tileScreenSize = tileSize * scale;
          const isZoomedOut = tileScreenSize < 72;
          const now = Date.now();

          for (let row = startRow; row < endRow; row++) {
            for (let col = startCol; col < endCol; col++) {
              const key = row + "," + col;
              const x = offsetX + col * tileSize * scale;
              const y = offsetY + row * tileSize * scale;

              const isDirt = filled.has(key);
              if (isDirt) {
                ctx.drawImage(dirtImg, x, y, tileScreenSize, tileScreenSize);
              } else {
                ctx.drawImage(grassImg, x, y, tileScreenSize, tileScreenSize);
              }

              const plot = plots.get(key);
              if (!plot) continue;

              const crop = crops[plot.cropKey];
              const stock = stocks[plot.stockKey];
              if (!crop || !stock) continue;
              if (!crop.images.length) continue;

              const elapsed = now - plot.plantedAt;
              const progress = Math.min(1, elapsed / crop.growTimeMs);
              const isReady = progress >= 1;

              let phaseIndex;
              if (isReady) {
                phaseIndex = 3;
              } else {
                phaseIndex = Math.min(2, Math.floor(progress * 3));
              }

              const img =
                crop.images[phaseIndex] || crop.images[crop.images.length - 1];

              const pctChange =
                (stock.price - plot.stockPriceAtPlant) / plot.stockPriceAtPlant;
              const value = Math.max(0, crop.baseValue * (1 + pctChange));

              if (isZoomedOut) {
                const bgColor = isReady
                  ? "rgba(60,45,0,0.35)"
                  : "rgba(0,0,0,0.35)";
                ctx.fillStyle = bgColor;
                ctx.fillRect(x, y, tileScreenSize, tileScreenSize);

                if (pctChange !== 0) {
                  const tintColor =
                    pctChange > 0
                      ? "rgba(16,255,80,0.45)"
                      : "rgba(255,32,32,0.45)";
                  ctx.fillStyle = tintColor;
                  ctx.fillRect(x, y, tileScreenSize, tileScreenSize);
                }

                ctx.drawImage(img, x, y, tileScreenSize, tileScreenSize);

                if (!isReady) {
                  const remainingMs = Math.max(0, crop.growTimeMs - elapsed);
                  const secs = Math.ceil(remainingMs / 1000);
                  const mins = Math.floor(secs / 60);
                  const secPart = secs % 60;
                  const timerText =
                    mins + ":" + secPart.toString().padStart(2, "0");

                  const cx = x + tileScreenSize / 2;
                  const cy = y + tileScreenSize / 2;

                  ctx.save();
                  ctx.textAlign = "center";
                  ctx.textBaseline = "middle";
                  ctx.font = `${
                    tileScreenSize * 0.38
                  }px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif`;
                  ctx.fillStyle = "white";
                  ctx.fillText(timerText, cx, cy);
                  ctx.restore();
                }

                continue;
              }

              ctx.drawImage(img, x, y, tileScreenSize, tileScreenSize);

              const pad = 3 * scale;
              const infoHeight = 32 * scale;

              const hudColor = isReady
                ? "rgba(60,45,0,0.65)"
                : "rgba(0,0,0,0.65)";

              ctx.fillStyle = hudColor;
              ctx.fillRect(x, y, tileScreenSize, infoHeight);

              ctx.textBaseline = "top";
              ctx.font = `${
                9 * scale
              }px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif`;

              const pctText = `${pctChange >= 0 ? "+" : ""}${(
                pctChange * 100
              ).toFixed(1)}%`;
              const labelText = `${plot.stockKey} ${pctText}`;
              const baseX = x + pad;
              const baseY = y + pad;

              ctx.fillStyle = "white";
              ctx.fillText(labelText, baseX, baseY);

              if (pctChange > 0) {
                const upArrow = "▲";
                const labelWidth = ctx.measureText(labelText + " ").width;
                ctx.fillStyle = "#22c55e";
                ctx.fillText(upArrow, baseX + labelWidth, baseY);
              } else if (pctChange < 0) {
                const downArrow = "▼";
                const labelWidth = ctx.measureText(labelText + " ").width;
                ctx.fillStyle = "#ef4444";
                ctx.fillText(downArrow, baseX + labelWidth, baseY);
              }

              const valueText = "$" + value.toFixed(2);
              ctx.fillStyle = "white";
              ctx.fillText(valueText, x + pad, y + pad + 10 * scale);

              if (!isReady) {
                const remainingMs = Math.max(0, crop.growTimeMs - elapsed);
                const secs = Math.ceil(remainingMs / 1000);
                const mins = Math.floor(secs / 60);
                const secPart = secs % 60;
                const timerText =
                  mins + ":" + secPart.toString().padStart(2, "0");
                ctx.fillText(timerText, x + pad, y + pad + 20 * scale);
              } else {
                ctx.fillText("Ready", x + pad, y + pad + 20 * scale);
              }
            }
          }

          ctx.strokeStyle = "rgba(30,30,30,0.9)";
          ctx.lineWidth = Math.max(0.5, scale * 0.4);

          ctx.beginPath();

          for (let col = startCol; col <= endCol; col++) {
            const x = offsetX + col * tileSize * scale;
            ctx.moveTo(x, offsetY + startRow * tileSize * scale);
            ctx.lineTo(x, offsetY + endRow * tileSize * scale);
          }

          for (let row = startRow; row <= endRow; row++) {
            const y = offsetY + row * tileSize * scale;
            ctx.moveTo(offsetX + startCol * tileSize * scale, y);
            ctx.lineTo(offsetX + endCol * tileSize * scale, y);
          }

          ctx.stroke();
        }

        function loop() {
          render();
          requestAnimationFrame(loop);
        }

        function updatePointer(e) {
          activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
        }

        function getTwoPointers() {
          const vals = Array.from(activePointers.values());
          return vals.length >= 2 ? [vals[0], vals[1]] : null;
        }

        function worldFromClient(clientX, clientY) {
          const rect = canvas.getBoundingClientRect();
          const x = clientX - rect.left;
          const y = clientY - rect.top;
          const worldX = (x - offsetX) / scale;
          const worldY = (y - offsetY) / scale;
          return { worldX, worldY };
        }

        function tileFromClient(clientX, clientY) {
          const { worldX, worldY } = worldFromClient(clientX, clientY);
          const col = Math.floor(worldX / tileSize);
          const row = Math.floor(worldY / tileSize);
          if (row < 0 || row >= GRID_ROWS || col < 0 || col >= GRID_COLS)
            return null;
          return { row, col, key: row + "," + col };
        }

        function harvestPlot(key) {
          const plot = plots.get(key);
          if (!plot) return;
          const crop = crops[plot.cropKey];
          const stock = stocks[plot.stockKey];
          if (!crop || !stock) return;
          const pctChange =
            (stock.price - plot.stockPriceAtPlant) / plot.stockPriceAtPlant;
          const value = Math.max(0, crop.baseValue * (1 + pctChange));
          totalMoney += value;
          updateTotalDisplay();
          plots.delete(key);
          needsRender = true;
          saveState();
        }

        function handleTap(clientX, clientY) {
          const tile = tileFromClient(clientX, clientY);
          if (!tile) return;
          const { key } = tile;

          if (!filled.has(key)) {
            if (totalMoney >= 5) {
              totalMoney -= 5;
              updateTotalDisplay();
              filled.add(key);
              needsRender = true;
              saveState();
            }
            return;
          }

          const existingPlot = plots.get(key);
          if (existingPlot) {
            const crop = crops[existingPlot.cropKey];
            if (!crop) return;
            const elapsed = Date.now() - existingPlot.plantedAt;
            if (elapsed >= crop.growTimeMs) {
              harvestPlot(key);
            }
            return;
          }

          const cropKey = selectedCropKey;
          const stockKey = selectedStockKey;
          const crop = crops[cropKey];
          const stock = stocks[stockKey];
          if (!crop || !stock || !crop.unlocked) return;

          plots.set(key, {
            cropKey,
            stockKey,
            plantedAt: Date.now(),
            stockPriceAtPlant: stock.price,
          });

          needsRender = true;
          saveState();
        }

        function onPointerDown(e) {
          canvas.setPointerCapture(e.pointerId);
          updatePointer(e);

          if (activePointers.size === 2) {
            isDragging = false;
            isPinching = true;

            const [p1, p2] = getTwoPointers();
            pinchStartDistance = Math.hypot(p2.x - p1.x, p2.y - p1.y);
            pinchStartScale = scale;
            pinchCenterX = (p1.x + p2.x) / 2;
            pinchCenterY = (p1.y + p2.y) / 2;
            tapStart = null;
          } else if (activePointers.size === 1) {
            isPinching = false;
            isDragging = true;

            dragStartX = e.clientX;
            dragStartY = e.clientY;
            dragOffsetStartX = offsetX;
            dragOffsetStartY = offsetY;

            tapStart = {
              id: e.pointerId,
              x: e.clientX,
              y: e.clientY,
              time: performance.now(),
            };
          }
        }

        function onPointerMove(e) {
          updatePointer(e);

          if (isPinching && activePointers.size === 2) {
            e.preventDefault();
            const [p1, p2] = getTwoPointers();
            const d = Math.hypot(p2.x - p1.x, p2.y - p1.y);

            if (pinchStartDistance > 0) {
              const newScale = clampScale(
                pinchStartScale * (d / pinchStartDistance)
              );
              const k = newScale / scale;

              offsetX = pinchCenterX - (pinchCenterX - offsetX) * k;
              offsetY = pinchCenterY - (pinchCenterY - offsetY) * k;
              scale = newScale;
              needsRender = true;
            }
          } else if (isDragging) {
            e.preventDefault();
            offsetX = dragOffsetStartX + (e.clientX - dragStartX);
            offsetY = dragOffsetStartY + (e.clientY - dragStartY);
            needsRender = true;

            if (tapStart) {
              const dx = e.clientX - tapStart.x;
              const dy = e.clientY - tapStart.y;
              if (dx * dx + dy * dy > 25) {
                tapStart = null;
              }
            }
          }
        }

        function onPointerUp(e) {
          activePointers.delete(e.pointerId);
          canvas.releasePointerCapture(e.pointerId);
          if (activePointers.size < 2) isPinching = false;
          if (activePointers.size === 0) isDragging = false;

          if (tapStart && tapStart.id === e.pointerId) {
            const dt = performance.now() - tapStart.time;
            const dx = e.clientX - tapStart.x;
            const dy = e.clientY - tapStart.y;
            if (dt < 300 && dx * dx + dy * dy <= 25) {
              handleTap(e.clientX, e.clientY);
            }
          }
          tapStart = null;
        }

        function onWheel(e) {
          e.preventDefault();

          const rect = canvas.getBoundingClientRect();
          const cx = rect.width / 2;
          const cy = rect.height / 2;

          const factor = e.deltaY < 0 ? 1.1 : 1 / 1.1;
          zoomAt(factor, cx, cy);
        }

        canvas.addEventListener("pointerdown", onPointerDown);
        canvas.addEventListener("pointermove", onPointerMove);
        canvas.addEventListener("pointerup", onPointerUp);
        canvas.addEventListener("pointercancel", onPointerUp);
        canvas.addEventListener("pointerleave", onPointerUp);
        canvas.addEventListener("wheel", onWheel, { passive: false });

        window.addEventListener("resize", () => {
          resizeCanvas();
          needsRender = true;
        });

        const navToggle = document.getElementById("navToggle");
        const navOffcanvas = document.getElementById("navOffcanvas");
        const navOverlay = document.getElementById("navOverlay");
        const navClose = document.getElementById("navClose");
        const recenterBtn = document.getElementById("recenterBtn");
        const cropGrid = document.getElementById("cropGrid");
        const stockGrid = document.getElementById("stockGrid");

        function openOffcanvas() {
          navOffcanvas.classList.remove("translate-x-full");
          navOverlay.classList.remove("hidden");
          navToggle.setAttribute("aria-expanded", "true");
        }

        function closeOffcanvas() {
          navOffcanvas.classList.add("translate-x-full");
          navOverlay.classList.add("hidden");
          navToggle.setAttribute("aria-expanded", "false");
        }

        function toggleOffcanvas() {
          const isClosed = navOffcanvas.classList.contains("translate-x-full");
          if (isClosed) openOffcanvas();
          else closeOffcanvas();
        }

        if (navToggle) {
          navToggle.addEventListener("click", toggleOffcanvas);
        }

        navClose.addEventListener("click", closeOffcanvas);
        navOverlay.addEventListener("click", closeOffcanvas);

        document.addEventListener("keydown", (e) => {
          if (e.key === "Escape") {
            closeOffcanvas();
          }
        });

        if (recenterBtn) {
          recenterBtn.addEventListener("click", () => {
            centerView();
            closeOffcanvas();
          });
        }

        function renderCropOptions() {
          if (!cropGrid) return;
          cropGrid.innerHTML = "";
          Object.values(crops).forEach((crop) => {
            const card = document.createElement("button");
            card.type = "button";
            let baseClass =
              "relative w-full aspect-square rounded-md overflow-hidden border text-left bg-neutral-900";
            if (crop.id === selectedCropKey) {
              baseClass += " border-emerald-500 ring-1 ring-emerald-500";
            } else {
              baseClass += " border-neutral-700 hover:border-neutral-500";
            }
            if (!crop.unlocked) {
              baseClass += " opacity-40 grayscale cursor-pointer";
            } else {
              baseClass += " cursor-pointer";
            }
            card.className = baseClass;

            const img = document.createElement("img");
            img.src = `images/${crop.id}/${crop.id}-phase-4.png`;
            img.alt = crop.name;
            img.className = "absolute inset-0 w-full h-full object-cover";
            card.appendChild(img);

            const overlay = document.createElement("div");
            overlay.className =
              "relative z-10 h-full flex flex-col justify-end bg-gradient-to-t from-black/85 via-black/50 to-transparent p-2 text-[10px] space-y-0.5";

            overlay.innerHTML =
              `<div class="font-semibold text-xs text-white">${crop.name}</div>` +
              `<div class="text-neutral-300">Grow time: ${crop.growMinutes} min</div>` +
              `<div class="text-neutral-200">Sell price: $${crop.baseValue.toFixed(
                2
              )}</div>`;

            if (!crop.unlocked && crop.unlockCost > 0) {
              overlay.innerHTML += `<div class="text-[9px] text-amber-300 mt-1">Unlock for: $${crop.unlockCost.toFixed(
                2
              )}</div>`;
            }

            card.appendChild(overlay);

            card.addEventListener("click", () => {
              if (!crop.unlocked) {
                if (crop.unlockCost > 0 && totalMoney >= crop.unlockCost) {
                  totalMoney -= crop.unlockCost;
                  crop.unlocked = true;
                  selectedCropKey = crop.id;
                  previousCropKey = crop.id;
                  updateTotalDisplay();
                  renderCropOptions();
                  updateCurrentSelectionLabel();
                  saveState();
                }
                return;
              }
              selectedCropKey = crop.id;
              previousCropKey = crop.id;
              renderCropOptions();
              updateCurrentSelectionLabel();
              saveState();
            });

            cropGrid.appendChild(card);
          });
        }

        function renderStockOptions() {
          if (!stockGrid) return;
          stockGrid.innerHTML = "";
          Object.values(stocks).forEach((stock) => {
            const btn = document.createElement("button");
            btn.type = "button";
            let cls =
              "w-full aspect-square rounded-md border flex items-center justify-center text-[11px] font-semibold tracking-wide";
            if (stock.symbol === selectedStockKey) {
              cls += " border-emerald-500 bg-emerald-500/10";
            } else {
              cls += " border-neutral-700 bg-neutral-900 hover:bg-neutral-800";
            }
            btn.className = cls;
            btn.textContent = stock.symbol;
            btn.addEventListener("click", () => {
              selectedStockKey = stock.symbol;
              renderStockOptions();
              updateCurrentSelectionLabel();
              saveState();
            });
            stockGrid.appendChild(btn);
          });
        }

        setInterval(() => {
          Object.values(stocks).forEach((s) => {
            const factor = 1 + (Math.random() - 0.5) * 0.01;
            s.price = Math.max(1, s.price * factor);
          });
          needsRender = true;
        }, 1000);

        updateTotalDisplay();
        renderCropOptions();
        renderStockOptions();
        updateCurrentSelectionLabel();
        resizeCanvas();
        loop();
      })();
    </script>
  </body>
</html>
