<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Stock Farmer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
      }
      body {
        display: flex;
        flex-direction: column;
        background-color: #000;
      }
      .canvas-wrapper {
        flex: 1 1 auto;
        position: relative;
        overflow: hidden;
      }
      #gridCanvas {
        width: 100%;
        height: 100%;
        display: block;
        touch-action: none;
        background-color: #000;
      }
    </style>
  </head>
  <body class="bg-black text-white">
    <nav class="bg-neutral-900 text-white">
      <div class="flex items-center px-4 py-2 relative">
        <a class="text-sm font-semibold whitespace-nowrap" href="#">Stock Farmer</a>

        <div id="currentSelection" class="absolute left-1/2 -translate-x-1/2 text-[11px] font-mono text-neutral-300 whitespace-nowrap overflow-hidden text-ellipsis opacity-0 transition-opacity"></div>

        <div class="ml-auto flex items-center gap-2">
          <div id="totalDisplay" class="text-xs font-mono px-2 py-1 rounded bg-neutral-800">$0.00</div>
          <button
            id="navToggle"
            class="inline-flex items-center justify-center p-2 rounded-md border border-gray-500 hover:bg-neutral-800 focus:outline-none"
            type="button"
            aria-controls="navOffcanvas"
            aria-expanded="false">
            <span class="sr-only">Open controls</span>
            <svg class="h-4 w-4" viewBox="0 0 20 20" fill="none">
              <path d="M3 5h14M3 10h14M3 15h14" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" />
            </svg>
          </button>
        </div>
      </div>
    </nav>

    <div id="navOverlay" class="fixed inset-0 bg-black/50 hidden z-30"></div>

    <div id="navOffcanvas" class="fixed inset-y-0 right-0 w-64 bg-neutral-900 text-white shadow-xl transform translate-x-full transition-transform duration-200 z-40 flex flex-col">
      <div class="flex items-center justify-between px-4 py-3 border-b border-neutral-700">
        <h5 class="text-sm font-semibold" id="navOffcanvasLabel">Controls</h5>
        <button id="navClose" class="p-1 rounded-md hover:bg-neutral-800 focus:outline-none">
          <span class="sr-only">Close</span>
          <svg class="h-4 w-4" viewBox="0 0 20 20" fill="none" aria-hidden="true">
            <path d="M5 5l10 10M15 5L5 15" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" />
          </svg>
        </button>
      </div>
      <div class="flex-1 p-4 text-xs text-neutral-300 space-y-4 overflow-y-auto">
        <div>
          <p class="mb-2 font-medium text-neutral-200">Crop</p>
          <div id="cropGrid" class="grid grid-cols-2 gap-2"></div>
        </div>

        <div>
          <p class="mb-2 font-medium text-neutral-200">Stock</p>
          <div id="stockGrid" class="grid grid-cols-3 gap-2"></div>
        </div>

        <div>
          <p class="mb-2 font-medium text-neutral-200">Tool</p>
          <div id="toolGrid" class="grid grid-cols-4 gap-2"></div>
        </div>

        <div class="flex items-center justify-between text-[11px]">
          <span class="text-neutral-200">Show stock stats</span>
          <button id="toggleStatsBtn" class="px-2 py-1 rounded border border-neutral-600 text-[11px] bg-neutral-800" type="button">On</button>
        </div>

        <button class="w-full border border-gray-500 text-xs px-3 py-2 rounded-md hover:bg-neutral-800 flex items-center justify-center text-center" id="recenterBtn">Recenter view</button>
      </div>
    </div>

    <div class="canvas-wrapper">
      <canvas id="gridCanvas"></canvas>
    </div>

    <!-- Farmland limit dialog -->
    <div id="farmlandDialogOverlay" class="fixed inset-0 bg-black/60 hidden z-50 flex items-center justify-center">
      <div class="bg-neutral-900 border border-neutral-700 rounded-lg shadow-lg w-72 p-4 text-xs text-neutral-100">
        <div class="flex items-center justify-between mb-2">
          <h2 class="text-sm font-semibold">Increase Farmland Limit</h2>
          <button id="farmlandDialogClose" class="text-neutral-400 hover:text-neutral-200 text-sm" type="button">&times;</button>
        </div>
        <p class="mb-2 text-neutral-300" id="farmlandDialogCurrent"></p>
        <div class="mb-2">
          <span class="text-neutral-300">Plots to unlock</span>
          <div class="mt-1 flex items-center gap-2">
            <button id="farmlandDialogDecrement" type="button" class="w-7 h-7 rounded-full border border-neutral-500 bg-neutral-800 flex items-center justify-center text-sm">-</button>
            <span id="farmlandDialogAmountDisplay" class="min-w-[2rem] text-center text-base">1</span>
            <button id="farmlandDialogIncrement" type="button" class="w-7 h-7 rounded-full border border-neutral-500 bg-neutral-800 flex items-center justify-center text-sm">+</button>
          </div>
        </div>
        <p class="mb-1 text-neutral-300" id="farmlandDialogCost"></p>
        <p class="mb-3 text-neutral-300" id="farmlandDialogResult"></p>
        <div class="flex justify-end gap-2">
          <button id="farmlandDialogCancel" class="px-3 py-1 rounded border border-neutral-600 text-[11px] bg-neutral-800" type="button">Cancel</button>
          <button id="farmlandDialogConfirm" class="px-3 py-1 rounded bg-sky-600 text-white text-[11px] disabled:opacity-40 disabled:cursor-not-allowed" type="button">Confirm</button>
        </div>
      </div>
    </div>

    <script>
      (function () {
        const canvas = document.getElementById("gridCanvas");
        const ctx = canvas.getContext("2d");

        const GRID_COLS = 100;
        const GRID_ROWS = 100;

        let tileSize = 100;
        const VISIBLE_ROWS_AT_START = 3;

        let offsetX = 0;
        let offsetY = 0;
        let scale = 1;
        let defaultScale = 1;
        const MIN_SCALE = 0.05;
        const MAX_SCALE = 3;

        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let dragOffsetStartX = 0;
        let dragOffsetStartY = 0;

        const activePointers = new Map();
        let isPinching = false;
        let pinchStartDistance = 0;
        let pinchStartScale = 1;
        let pinchCenterX = 0;
        let pinchCenterY = 0;

        let tapStart = null;

        let needsRender = true;
        let firstResizeDone = false;
        let savedScaleFromState = null;
        let scaleChanged = false;

        let totalMoney = 0;
        let showStats = true;

        const totalDisplay = document.getElementById("totalDisplay");
        const currentSelectionEl = document.getElementById("currentSelection");

        const crops = {
          grass: {
            id: "grass",
            name: "Grass",
            growMinutes: 0,
            baseValue: 0,
            unlocked: true,
            unlockCost: 0,
            images: [],
            limit: -1,
            placed: 0,
          },
          farmland: {
            id: "farmland",
            name: "Farmland",
            growMinutes: 0,
            baseValue: 0,
            unlocked: true,
            unlockCost: 0,
            images: [],
            limit: 4,
            placed: 0,
            limitIncreaseCost: 100,
          },
          wheat: {
            id: "wheat",
            name: "Wheat",
            growMinutes: 1,
            baseValue: 1,
            unlocked: true,
            unlockCost: 0,
            images: [],
            limit: -1,
            placed: 0,
          },
          carrot: {
            id: "carrot",
            name: "Carrot",
            growMinutes: 5,
            baseValue: 5,
            unlocked: false,
            unlockCost: 100,
            placeCost: 2.5,
            images: [],
            limit: -1,
            placed: 0,
          },
          potato: {
            id: "potato",
            name: "Potato",
            growMinutes: 10,
            baseValue: 10,
            unlocked: false,
            unlockCost: 1000,
            placeCost: 5,
            images: [],
            limit: -1,
            placed: 0,
          },
        };

        function loadCropImages(crop) {
          crop.growTimeMs = crop.growMinutes * 60 * 1000;
          crop.images = Array.from({ length: 4 }, (_, i) => {
            const img = new Image();
            img.src = `images/${crop.id}/${crop.id}-phase-${i + 1}.png`;
            img.onload = () => (needsRender = true);
            return img;
          });
        }

        Object.values(crops)
          .filter((c) => c.id !== "grass" && c.id !== "farmland")
          .forEach(loadCropImages);

        const stocks = {
          SP500: { symbol: "SP500", name: "S&P 500", price: 100 },
          AMZN: { symbol: "AMZN", name: "AMZN", price: 100 },
          TSLA: { symbol: "TSLA", name: "TSLA", price: 100 },
        };

        const tools = {
          single: {
            id: "single",
            name: "1x1",
            size: 1,
            unlocked: true,
            unlockCost: 0,
          },
          square2: {
            id: "square2",
            name: "2x2",
            size: 2,
            unlocked: false,
            unlockCost: 1000,
          },
          square3: {
            id: "square3",
            name: "3x3",
            size: 3,
            unlocked: false,
            unlockCost: 25000,
          },
          square5: {
            id: "square5",
            name: "5x5",
            size: 5,
            unlocked: false,
            unlockCost: 100000,
          },
        };

        let selectedCropKey = "wheat";
        let previousCropKey = "wheat";
        let selectedStockKey = "SP500";
        let selectedToolKey = "single";

        const plots = new Map();
        const harvestAnimations = [];
        const costAnimations = [];

        const defaultFilled = ["49,49", "49,50", "50,49", "50,50"];
        const filled = new Set(defaultFilled);

        const SAVE_KEY = "stockFarmerState";

        function saveState() {
          const data = {
            totalMoney,
            filled: Array.from(filled),
            plots: Array.from(plots.entries()),
            selectedCropKey,
            previousCropKey,
            selectedStockKey,
            selectedToolKey,
            showStats,
            scale,
            cropsUnlocked: Object.fromEntries(Object.entries(crops).map(([id, c]) => [id, c.unlocked])),
            toolsUnlocked: Object.fromEntries(Object.entries(tools).map(([id, t]) => [id, t.unlocked])),
            cropLimits: Object.fromEntries(Object.entries(crops).map(([id, c]) => [id, typeof c.limit === "number" ? c.limit : -1])),
          };
          try {
            localStorage.setItem(SAVE_KEY, JSON.stringify(data));
          } catch (err) {
            console.error("Failed to save state", err);
          }
        }

        function loadState() {
          let raw;
          try {
            raw = localStorage.getItem(SAVE_KEY);
          } catch (err) {
            console.error("Failed to read state", err);
            return;
          }
          if (!raw) return;

          try {
            const data = JSON.parse(raw);

            if (typeof data.totalMoney === "number") {
              totalMoney = data.totalMoney;
            }

            if (Array.isArray(data.filled)) {
              filled.clear();
              data.filled.forEach((k) => filled.add(k));
            }

            if (Array.isArray(data.plots)) {
              plots.clear();
              data.plots.forEach(([key, value]) => {
                plots.set(key, value);
              });
            }

            if (data.cropsUnlocked) {
              Object.entries(data.cropsUnlocked).forEach(([id, unlocked]) => {
                if (crops[id]) crops[id].unlocked = !!unlocked;
              });
            }

            if (data.toolsUnlocked) {
              Object.entries(data.toolsUnlocked).forEach(([id, unlocked]) => {
                if (tools[id]) tools[id].unlocked = !!unlocked;
              });
            }

            if (data.cropLimits) {
              Object.entries(data.cropLimits).forEach(([id, limit]) => {
                if (crops[id] && typeof limit === "number") {
                  crops[id].limit = limit;
                }
              });
            }

            if (data.selectedCropKey && crops[data.selectedCropKey]) {
              selectedCropKey = data.selectedCropKey;
              previousCropKey = data.previousCropKey || selectedCropKey;
            }

            if (data.selectedStockKey && stocks[data.selectedStockKey]) {
              selectedStockKey = data.selectedStockKey;
            }

            if (data.selectedToolKey && tools[data.selectedToolKey]) {
              selectedToolKey = data.selectedToolKey;
            }

            if (typeof data.showStats === "boolean") {
              showStats = data.showStats;
            }

            if (typeof data.scale === "number") {
              savedScaleFromState = data.scale;
            }

            needsRender = true;
          } catch (err) {
            console.error("State load failed", err);
          }
        }

        function recalcPlacedCounts() {
          Object.values(crops).forEach((c) => {
            c.placed = 0;
          });

          const farmlandCrop = crops.farmland;
          if (farmlandCrop) {
            farmlandCrop.placed = filled.size;
          }

          plots.forEach((plot) => {
            const crop = crops[plot.cropKey];
            if (crop) {
              crop.placed += 1;
            }
          });
        }

        loadState();

        if (!localStorage.getItem(SAVE_KEY)) {
          selectedCropKey = "wheat";
          previousCropKey = "wheat";
          selectedStockKey = "SP500";
          selectedToolKey = "single";
        }

        recalcPlacedCounts();

        const dirtImg = new Image();
        let dirtLoaded = false;
        dirtImg.src = "images/dirt.jpg";
        dirtImg.onload = () => {
          dirtLoaded = true;
          needsRender = true;
        };

        const grassImg = new Image();
        let grassLoaded = false;
        grassImg.src = "images/grass.jpg";
        grassImg.onload = () => {
          grassLoaded = true;
          needsRender = true;
        };

        function updateTotalDisplay() {
          const text = "$" + totalMoney.toFixed(2);
          if (totalDisplay) totalDisplay.textContent = text;
        }

        function updateCurrentSelectionLabel() {
          if (!currentSelectionEl) return;
          const crop = crops[selectedCropKey];
          const stock = stocks[selectedStockKey];

          if (!crop) {
            currentSelectionEl.innerHTML = "";
            currentSelectionEl.classList.add("opacity-0");
            return;
          }

          if (crop.id === "grass") {
            const cropBubble = '<span class="inline-flex items-center px-2 py-0.5 rounded bg-neutral-800 text-neutral-100 mx-0.5">' + crop.name + "</span>";

            currentSelectionEl.innerHTML = '<span class="hidden sm:inline">Currently planting ' + cropBubble + "</span>" + '<span class="inline sm:hidden">' + crop.name + "</span>";

            currentSelectionEl.classList.remove("opacity-0");
            return;
          }

          if (crop.id === "farmland") {
            const cropBubble = '<span class="inline-flex items-center px-2 py-0.5 rounded bg-neutral-800 text-neutral-100 mx-0.5">' + crop.name + "</span>";

            currentSelectionEl.innerHTML = '<span class="hidden sm:inline">Currently placing ' + cropBubble + "</span>" + '<span class="inline sm:hidden">' + crop.name + "</span>";

            currentSelectionEl.classList.remove("opacity-0");
            return;
          }

          if (!stock) {
            currentSelectionEl.innerHTML = "";
            currentSelectionEl.classList.add("opacity-0");
            return;
          }

          const cropBubbleDesktop = '<span class="inline-flex items-center px-2 py-0.5 rounded bg-neutral-800 text-neutral-100 mx-0.5">' + crop.name + "</span>";
          const stockBubbleDesktop = '<span class="inline-flex items-center px-2 py-0.5 rounded bg-neutral-800 text-neutral-100 mx-0.5">' + stock.name + "</span>";

          const cropBubbleMobile = '<span class="inline-flex items-center px-2 py-0.5 rounded bg-neutral-800 text-neutral-100 mx-0.5">' + crop.name + "</span>";
          const stockBubbleMobile = '<span class="inline-flex items-center px-2 py-0.5 rounded bg-neutral-800 text-neutral-100 mx-0.5">' + stock.symbol + "</span>";

          currentSelectionEl.innerHTML =
            '<span class="hidden sm:inline">' +
            "Currently planting " +
            cropBubbleDesktop +
            " tracking " +
            stockBubbleDesktop +
            "</span>" +
            '<span class="inline sm:hidden">' +
            cropBubbleMobile +
            " / " +
            stockBubbleMobile +
            "</span>";

          currentSelectionEl.classList.remove("opacity-0");
        }

        function centerView() {
          const rect = canvas.getBoundingClientRect();
          const worldWidth = GRID_COLS * tileSize;
          const worldHeight = GRID_ROWS * tileSize;
          const canvasWidth = rect.width;
          const canvasHeight = rect.height;
          const worldCenterX = worldWidth / 2;
          const worldCenterY = worldHeight / 2;
          const canvasCenterX = canvasWidth / 2;
          const canvasCenterY = canvasHeight / 2;

          offsetX = canvasCenterX - worldCenterX * scale;
          offsetY = canvasCenterY - worldCenterY * scale;

          needsRender = true;
        }

        function resizeCanvas() {
          const rect = canvas.getBoundingClientRect();
          const dpr = window.devicePixelRatio || 1;

          canvas.width = rect.width * dpr;
          canvas.height = rect.height * dpr;
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

          const scaleFromHeight = rect.height / (VISIBLE_ROWS_AT_START * tileSize);
          const scaleFromWidth = rect.width / (VISIBLE_ROWS_AT_START * tileSize);
          const initialScale = Math.min(scaleFromHeight, scaleFromWidth);

          if (!firstResizeDone) {
            const targetScale = savedScaleFromState != null ? clampScale(savedScaleFromState) : initialScale;
            scale = targetScale;
            defaultScale = targetScale;
            firstResizeDone = true;
          }

          centerView();
        }

        function clampScale(s) {
          return Math.min(MAX_SCALE, Math.max(MIN_SCALE, s));
        }

        function zoomAt(factor, cx, cy) {
          const newScale = clampScale(scale * factor);
          const k = newScale / scale;
          offsetX = cx - (cx - offsetX) * k;
          offsetY = cy - (cy - offsetY) * k;
          scale = newScale;
          scaleChanged = true;
          needsRender = true;
          saveState();
          scaleChanged = false;
        }

        function renderFloatingValue(anim, nowPerf, startRow, endRow, startCol, endCol) {
          const visibleDuration = 1000;
          const fadeDuration = 500;
          const totalDuration = visibleDuration + fadeDuration;

          const elapsed = nowPerf - anim.start;
          if (elapsed >= totalDuration) {
            return true;
          }

          const [rowStr, colStr] = anim.key.split(",");
          const row = parseInt(rowStr, 10);
          const col = parseInt(colStr, 10);
          if (Number.isNaN(row) || Number.isNaN(col)) {
            return false;
          }

          if (row < startRow || row >= endRow || col < startCol || col >= endCol) {
            return false;
          }

          const cellX = offsetX + col * tileSize * scale;
          const cellY = offsetY + row * tileSize * scale;
          const cx = cellX + (tileSize * scale) / 2;
          const cy = cellY + (tileSize * scale) / 2;

          let alpha;
          if (elapsed <= visibleDuration) {
            alpha = 1;
          } else {
            const fadeT = (elapsed - visibleDuration) / fadeDuration;
            alpha = 1 - Math.min(1, Math.max(0, fadeT));
          }

          const value = anim.value;
          const isPositiveOrZero = value >= 0;
          const absValue = Math.abs(value);
          const prefix = isPositiveOrZero ? "+$" : "-$";

          const cellScreenSize = tileSize * scale;
          const fontSize = cellScreenSize * 0.22;

          ctx.save();
          ctx.globalAlpha = alpha;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.font = `700 ${fontSize}px system-ui`;

          ctx.shadowColor = "rgba(0,0,0,0.3)";
          ctx.shadowBlur = cellScreenSize * 0.05;
          ctx.shadowOffsetX = 0;
          ctx.shadowOffsetY = cellScreenSize * 0.015;

          ctx.fillStyle = isPositiveOrZero ? "#22c55e" : "#ef4444";
          ctx.fillText(prefix + absValue.toFixed(2), cx, cy);
          ctx.restore();

          return false;
        }

        function render() {
          const hasAnimations = harvestAnimations.length > 0 || costAnimations.length > 0;
          if (!needsRender && !hasAnimations) return;
          needsRender = false;

          const width = canvas.clientWidth;
          const height = canvas.clientHeight;

          ctx.clearRect(0, 0, width, height);

          if (!dirtLoaded || !grassLoaded) return;

          const worldLeft = -offsetX / scale;
          const worldRight = (width - offsetX) / scale;
          const worldTop = -offsetY / scale;
          const worldBottom = (height - offsetY) / scale;

          const startCol = Math.max(0, Math.floor(worldLeft / tileSize));
          const endCol = Math.min(GRID_COLS, Math.ceil(worldRight / tileSize));
          const startRow = Math.max(0, Math.floor(worldTop / tileSize));
          const endRow = Math.min(GRID_ROWS, Math.ceil(worldBottom / tileSize));

          const tileScreenSize = tileSize * scale;
          const isZoomedOut = tileScreenSize < 72;
          const now = Date.now();
          const nowPerf = performance.now();

          for (let row = startRow; row < endRow; row++) {
            for (let col = startCol; col < endCol; col++) {
              const key = row + "," + col;
              const x = offsetX + col * tileSize * scale;
              const y = offsetY + row * tileSize * scale;

              const isDirt = filled.has(key);
              if (isDirt) {
                ctx.drawImage(dirtImg, x, y, tileScreenSize, tileScreenSize);
              } else {
                ctx.drawImage(grassImg, x, y, tileScreenSize, tileScreenSize);
              }

              const plot = plots.get(key);
              if (!plot) continue;

              const crop = crops[plot.cropKey];
              const stock = stocks[plot.stockKey];
              if (!crop || !stock) continue;
              if (!crop.images.length) continue;

              const elapsed = now - plot.plantedAt;
              const progress = Math.min(1, elapsed / crop.growTimeMs);
              const isReady = progress >= 1;

              if (isReady && plot.lockedStockPrice == null) {
                plot.lockedStockPrice = stock.price;
                saveState();
              }

              let phaseIndex;
              if (isReady) phaseIndex = 3;
              else phaseIndex = Math.min(2, Math.floor(progress * 3));

              const img = crop.images[phaseIndex] || crop.images[crop.images.length - 1];

              const effectivePrice = isReady && plot.lockedStockPrice != null ? plot.lockedStockPrice : stock.price;

              const pctChange = (effectivePrice - plot.stockPriceAtPlant) / plot.stockPriceAtPlant;

              const value = Math.max(0, crop.baseValue * (1 + pctChange));
              const pctText = `${pctChange >= 0 ? "+" : ""}${(pctChange * 100).toFixed(1)}%`;
              const valueText = "$" + value.toFixed(2);

              const remainingMs = Math.max(0, crop.growTimeMs - elapsed);
              const secs = Math.ceil(remainingMs / 1000);
              const mins = Math.floor(secs / 60);
              const secPart = secs % 60;
              const timerText = mins + ":" + secPart.toString().padStart(2, "0");

              let arrow = "";
              if (pctChange > 0) arrow = "▲";
              else if (pctChange < 0) arrow = "▼";

              let stockColor = "white";
              if (pctChange > 0) stockColor = "#22c55e";
              else if (pctChange < 0) stockColor = "#ef4444";

              if (isZoomedOut) {
                ctx.drawImage(img, x, y, tileScreenSize, tileScreenSize);

                if (showStats && !isReady) {
                  ctx.fillStyle = "rgba(0,0,0,0.7)";
                  ctx.fillRect(x, y, tileScreenSize, tileScreenSize);

                  ctx.save();
                  ctx.textAlign = "left";
                  ctx.textBaseline = "top";

                  const pad = tileScreenSize * 0.08;
                  let lineY = y + pad;
                  const baseX = x + pad;

                  ctx.font = `${tileScreenSize * 0.22}px system-ui`;
                  ctx.fillStyle = stockColor;
                  ctx.fillText(`${plot.stockKey} ${arrow}`, baseX, lineY);
                  lineY += tileScreenSize * 0.24;

                  ctx.font = `${tileScreenSize * 0.2}px system-ui`;
                  ctx.fillStyle = "white";
                  ctx.fillText(pctText, baseX, lineY);
                  lineY += tileScreenSize * 0.2;

                  ctx.fillText(valueText, baseX, lineY);
                  lineY += tileScreenSize * 0.2;

                  ctx.fillText(timerText, baseX, lineY);

                  ctx.restore();
                }

                continue;
              }

              ctx.drawImage(img, x, y, tileScreenSize, tileScreenSize);

              const pad = 3 * scale;
              const infoHeight = 32 * scale;

              if (showStats && !isReady) {
                ctx.fillStyle = "rgba(0,0,0,0.65)";
                ctx.fillRect(x, y, tileScreenSize, infoHeight);

                ctx.textBaseline = "top";
                ctx.font = `${9 * scale}px system-ui`;

                const baseX = x + pad;
                const baseY = y + pad;

                const tickerText = `${plot.stockKey} ${arrow}`;
                ctx.fillStyle = stockColor;
                ctx.fillText(tickerText, baseX, baseY);

                const tickerWidth = ctx.measureText(tickerText + " ").width;
                ctx.fillStyle = "white";
                ctx.fillText(pctText, baseX + tickerWidth, baseY);

                ctx.fillText(valueText, baseX, baseY + 10 * scale);
                ctx.fillText(timerText, baseX, baseY + 20 * scale);
              }
            }
          }

          for (let i = harvestAnimations.length - 1; i >= 0; i--) {
            const done = renderFloatingValue(harvestAnimations[i], nowPerf, startRow, endRow, startCol, endCol);
            if (done) {
              harvestAnimations.splice(i, 1);
            }
          }

          for (let i = costAnimations.length - 1; i >= 0; i--) {
            const done = renderFloatingValue(costAnimations[i], nowPerf, startRow, endRow, startCol, endCol);
            if (done) {
              costAnimations.splice(i, 1);
            }
          }

          if (harvestAnimations.length || costAnimations.length) {
            needsRender = true;
          }

          ctx.strokeStyle = "rgba(30,30,30,0.9)";
          ctx.lineWidth = Math.max(0.5, scale * 0.4);

          ctx.beginPath();

          for (let col = startCol; col <= endCol; col++) {
            const x = offsetX + col * tileSize * scale;
            ctx.moveTo(x, offsetY + startRow * tileSize * scale);
            ctx.lineTo(x, offsetY + endRow * tileSize * scale);
          }

          for (let row = startRow; row <= endRow; row++) {
            const y = offsetY + row * tileSize * scale;
            ctx.moveTo(offsetX + startCol * tileSize * scale, y);
            ctx.lineTo(offsetX + endCol * tileSize * scale, y);
          }

          ctx.stroke();
        }

        function loop() {
          render();
          requestAnimationFrame(loop);
        }

        function updatePointer(e) {
          activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
        }

        function getTwoPointers() {
          const vals = Array.from(activePointers.values());
          return vals.length >= 2 ? [vals[0], vals[1]] : null;
        }

        function worldFromClient(clientX, clientY) {
          const rect = canvas.getBoundingClientRect();
          const x = clientX - rect.left;
          const y = clientY - rect.top;
          const worldX = (x - offsetX) / scale;
          const worldY = (y - offsetY) / scale;
          return { worldX, worldY };
        }

        function tileFromClient(clientX, clientY) {
          const { worldX, worldY } = worldFromClient(clientX, clientY);
          const col = Math.floor(worldX / tileSize);
          const row = Math.floor(worldY / tileSize);
          if (row < 0 || row >= GRID_ROWS || col < 0 || col >= GRID_COLS) return null;
          return { row, col, key: row + "," + col };
        }

        function harvestPlot(key) {
          const plot = plots.get(key);
          if (!plot) return;
          const crop = crops[plot.cropKey];
          const stock = stocks[plot.stockKey];
          if (!crop || !stock) return;

          const effectivePrice = plot.lockedStockPrice != null ? plot.lockedStockPrice : stock.price;
          const pctChange = (effectivePrice - plot.stockPriceAtPlant) / plot.stockPriceAtPlant;
          const value = Math.max(0, crop.baseValue * (1 + pctChange));

          harvestAnimations.push({
            key,
            value,
            start: performance.now(),
          });

          if (typeof crop.placed === "number" && crop.placed > 0) {
            crop.placed -= 1;
          }

          totalMoney += value;
          updateTotalDisplay();
          plots.delete(key);
          needsRender = true;
          saveState();
        }

        function handleTileAction(row, col) {
          if (row < 0 || col < 0 || row >= GRID_ROWS || col >= GRID_COLS) return;
          const key = row + "," + col;
          const existingPlot = plots.get(key);
          if (existingPlot) {
            const crop = crops[existingPlot.cropKey];
            if (!crop) return;
            const elapsed = Date.now() - existingPlot.plantedAt;
            if (elapsed >= crop.growTimeMs) {
              harvestPlot(key);
            }
            return;
          }

          if (selectedCropKey === "grass") {
            const hadFarmland = filled.delete(key);
            if (hadFarmland && crops.farmland) {
              const f = crops.farmland;
              if (typeof f.placed === "number" && f.placed > 0) {
                f.placed -= 1;
              }
            }
            needsRender = true;
            renderCropOptions();
            saveState();
            return;
          }

          if (selectedCropKey === "farmland") {
            const farmlandCrop = crops.farmland;
            if (!farmlandCrop) return;
            if (plots.has(key)) return;
            if (filled.has(key)) return;

            if (typeof farmlandCrop.limit === "number" && farmlandCrop.limit >= 0 && farmlandCrop.placed >= farmlandCrop.limit) {
              return;
            }

            filled.add(key);
            farmlandCrop.placed += 1;
            needsRender = true;
            renderCropOptions();
            saveState();
            return;
          }

          if (!filled.has(key)) {
            return;
          }

          const cropKey = selectedCropKey;
          const stockKey = selectedStockKey;
          const crop = crops[cropKey];
          const stock = stocks[stockKey];
          if (!crop || !stock || !crop.unlocked) return;

          if (typeof crop.limit === "number" && crop.limit >= 0 && crop.placed >= crop.limit) {
            return;
          }

          const plantCost = typeof crop.placeCost === "number" ? crop.placeCost : 0;

          if (plantCost > 0) {
            if (totalMoney < plantCost) return;

            totalMoney -= plantCost;
            updateTotalDisplay();

            costAnimations.push({
              key,
              value: -plantCost,
              start: performance.now(),
            });
          }

          plots.set(key, {
            cropKey,
            stockKey,
            plantedAt: Date.now(),
            stockPriceAtPlant: stock.price,
            lockedStockPrice: null,
          });

          crop.placed += 1;

          needsRender = true;
          saveState();
        }

        function handleTap(clientX, clientY) {
          const tile = tileFromClient(clientX, clientY);
          if (!tile) return;
          const tool = tools[selectedToolKey] || tools.single;
          const size = tool.size || 1;
          const baseRow = tile.row;
          const baseCol = tile.col;

          for (let dr = 0; dr < size; dr++) {
            for (let dc = 0; dc < size; dc++) {
              const row = baseRow + dr;
              const col = baseCol + dc;
              handleTileAction(row, col);
            }
          }
        }

        function onPointerDown(e) {
          canvas.setPointerCapture(e.pointerId);
          updatePointer(e);

          if (activePointers.size === 2) {
            isDragging = false;
            isPinching = true;

            const [p1, p2] = getTwoPointers();
            pinchStartDistance = Math.hypot(p2.x - p1.x, p2.y - p1.y);
            pinchStartScale = scale;
            pinchCenterX = (p1.x + p2.x) / 2;
            pinchCenterY = (p1.y + p2.y) / 2;
            tapStart = null;
          } else if (activePointers.size === 1) {
            isPinching = false;
            isDragging = true;

            dragStartX = e.clientX;
            dragStartY = e.clientY;
            dragOffsetStartX = offsetX;
            dragOffsetStartY = offsetY;

            tapStart = {
              id: e.pointerId,
              x: e.clientX,
              y: e.clientY,
              time: performance.now(),
            };
          }
        }

        function onPointerMove(e) {
          updatePointer(e);

          if (isPinching && activePointers.size === 2) {
            e.preventDefault();
            const [p1, p2] = getTwoPointers();
            const d = Math.hypot(p2.x - p1.x, p2.y - p1.y);

            if (pinchStartDistance > 0) {
              const newScale = clampScale(pinchStartScale * (d / pinchStartDistance));
              const k = newScale / scale;

              offsetX = pinchCenterX - (pinchCenterX - offsetX) * k;
              offsetY = pinchCenterY - (pinchCenterY - offsetY) * k;
              scale = newScale;
              scaleChanged = true;
              needsRender = true;
            }
          } else if (isDragging) {
            e.preventDefault();
            offsetX = dragOffsetStartX + (e.clientX - dragStartX);
            offsetY = dragOffsetStartY + (e.clientY - dragStartY);
            needsRender = true;

            if (tapStart) {
              const dx = e.clientX - tapStart.x;
              const dy = e.clientY - tapStart.y;
              if (dx * dx + dy * dy > 25) {
                tapStart = null;
              }
            }
          }
        }

        function onPointerUp(e) {
          activePointers.delete(e.pointerId);
          canvas.releasePointerCapture(e.pointerId);
          if (activePointers.size < 2) isPinching = false;
          if (activePointers.size === 0) isDragging = false;

          if (tapStart && tapStart.id === e.pointerId) {
            const dt = performance.now() - tapStart.time;
            const dx = e.clientX - tapStart.x;
            const dy = e.clientY - tapStart.y;
            if (dt < 300 && dx * dx + dy * dy <= 25) {
              handleTap(e.clientX, e.clientY);
            }
          }
          tapStart = null;

          if (scaleChanged && activePointers.size === 0) {
            saveState();
            scaleChanged = false;
          }
        }

        function onWheel(e) {
          e.preventDefault();

          const rect = canvas.getBoundingClientRect();
          const cx = rect.width / 2;
          const cy = rect.height / 2;

          const factor = e.deltaY < 0 ? 1.1 : 1 / 1.1;
          zoomAt(factor, cx, cy);
        }

        canvas.addEventListener("pointerdown", onPointerDown);
        canvas.addEventListener("pointermove", onPointerMove);
        canvas.addEventListener("pointerup", onPointerUp);
        canvas.addEventListener("pointercancel", onPointerUp);
        canvas.addEventListener("pointerleave", onPointerUp);
        canvas.addEventListener("wheel", onWheel, { passive: false });

        window.addEventListener("resize", () => {
          resizeCanvas();
          needsRender = true;
        });

        const navToggle = document.getElementById("navToggle");
        const navOffcanvas = document.getElementById("navOffcanvas");
        const navOverlay = document.getElementById("navOverlay");
        const navClose = document.getElementById("navClose");
        const recenterBtn = document.getElementById("recenterBtn");
        const cropGrid = document.getElementById("cropGrid");
        const stockGrid = document.getElementById("stockGrid");
        const toolGrid = document.getElementById("toolGrid");
        const toggleStatsBtn = document.getElementById("toggleStatsBtn");

        const farmlandDialogOverlay = document.getElementById("farmlandDialogOverlay");
        const farmlandDialogCurrent = document.getElementById("farmlandDialogCurrent");
        const farmlandDialogCost = document.getElementById("farmlandDialogCost");
        const farmlandDialogResult = document.getElementById("farmlandDialogResult");
        const farmlandDialogConfirm = document.getElementById("farmlandDialogConfirm");
        const farmlandDialogCancel = document.getElementById("farmlandDialogCancel");
        const farmlandDialogClose = document.getElementById("farmlandDialogClose");
        const farmlandDialogAmountDisplay = document.getElementById("farmlandDialogAmountDisplay");
        const farmlandDialogIncrement = document.getElementById("farmlandDialogIncrement");
        const farmlandDialogDecrement = document.getElementById("farmlandDialogDecrement");

        let farmlandDialogAmountValue = 1;

        function updateFarmlandDialog() {
          const crop = crops.farmland;
          if (!crop) return;

          if (!Number.isFinite(farmlandDialogAmountValue) || farmlandDialogAmountValue < 1) {
            farmlandDialogAmountValue = 1;
          }

          if (farmlandDialogAmountDisplay) {
            farmlandDialogAmountDisplay.textContent = String(farmlandDialogAmountValue);
          }

          const amount = farmlandDialogAmountValue;
          const baseLimit = typeof crop.limit === "number" && crop.limit >= 0 ? crop.limit : crop.placed;

          const costPerPlot = typeof crop.limitIncreaseCost === "number" ? crop.limitIncreaseCost : 100;

          const totalCost = costPerPlot * amount;
          const newLimit = baseLimit + amount;

          if (farmlandDialogCurrent) {
            farmlandDialogCurrent.textContent = `Current limit: ${baseLimit} plots`;
          }
          if (farmlandDialogCost) {
            farmlandDialogCost.textContent = `Total cost: $${totalCost.toFixed(2)}`;
            const cannotAfford = totalCost > totalMoney;
            farmlandDialogCost.classList.toggle("text-red-400", cannotAfford);
            farmlandDialogCost.classList.toggle("text-neutral-300", !cannotAfford);
          }
          if (farmlandDialogResult) {
            farmlandDialogResult.textContent = `New limit: ${newLimit} plots`;
          }

          const canAfford = totalMoney >= totalCost && amount >= 1;
          if (farmlandDialogConfirm) {
            farmlandDialogConfirm.disabled = !canAfford;
          }
        }

        function openFarmlandDialog() {
          const crop = crops.farmland;
          if (!farmlandDialogOverlay || !crop) return;
          farmlandDialogOverlay.classList.remove("hidden");

          farmlandDialogAmountValue = 1;
          updateFarmlandDialog();
        }

        function closeFarmlandDialog() {
          if (!farmlandDialogOverlay) return;
          farmlandDialogOverlay.classList.add("hidden");
        }

        if (farmlandDialogIncrement) {
          farmlandDialogIncrement.addEventListener("click", () => {
            farmlandDialogAmountValue += 1;
            updateFarmlandDialog();
          });
        }

        if (farmlandDialogDecrement) {
          farmlandDialogDecrement.addEventListener("click", () => {
            if (farmlandDialogAmountValue > 1) {
              farmlandDialogAmountValue -= 1;
              updateFarmlandDialog();
            }
          });
        }

        if (farmlandDialogCancel) {
          farmlandDialogCancel.addEventListener("click", closeFarmlandDialog);
        }
        if (farmlandDialogClose) {
          farmlandDialogClose.addEventListener("click", closeFarmlandDialog);
        }
        if (farmlandDialogOverlay) {
          farmlandDialogOverlay.addEventListener("click", (e) => {
            if (e.target === farmlandDialogOverlay) {
              closeFarmlandDialog();
            }
          });
        }
        if (farmlandDialogConfirm) {
          farmlandDialogConfirm.addEventListener("click", () => {
            const crop = crops.farmland;
            if (!crop) return;

            const amount = farmlandDialogAmountValue;
            if (!Number.isFinite(amount) || amount < 1) return;

            const costPerPlot = typeof crop.limitIncreaseCost === "number" ? crop.limitIncreaseCost : 100;
            const totalCost = costPerPlot * amount;

            if (totalCost <= 0 || totalMoney < totalCost) return;

            totalMoney -= totalCost;
            const baseLimit = typeof crop.limit === "number" && crop.limit >= 0 ? crop.limit : crop.placed;

            crop.limit = baseLimit + amount;

            updateTotalDisplay();
            renderCropOptions();
            saveState();
            closeFarmlandDialog();
          });
        }

        function openOffcanvas() {
          navOffcanvas.classList.remove("translate-x-full");
          navOverlay.classList.remove("hidden");
          navToggle.setAttribute("aria-expanded", "true");
        }

        function closeOffcanvas() {
          navOffcanvas.classList.add("translate-x-full");
          navOverlay.classList.add("hidden");
          navToggle.setAttribute("aria-expanded", "false");
        }

        function toggleOffcanvas() {
          const isClosed = navOffcanvas.classList.contains("translate-x-full");
          if (isClosed) openOffcanvas();
          else closeOffcanvas();
        }

        function updateStatsToggleUI() {
          if (!toggleStatsBtn) return;
          toggleStatsBtn.textContent = showStats ? "On" : "Off";
          if (showStats) {
            toggleStatsBtn.classList.remove("bg-neutral-900", "text-neutral-400");
            toggleStatsBtn.classList.add("bg-emerald-600", "text-white");
          } else {
            toggleStatsBtn.classList.remove("bg-emerald-600", "text-white");
            toggleStatsBtn.classList.add("bg-neutral-900", "text-neutral-400");
          }
        }

        if (navToggle) {
          navToggle.addEventListener("click", toggleOffcanvas);
        }

        navClose.addEventListener("click", closeOffcanvas);
        navOverlay.addEventListener("click", closeOffcanvas);

        document.addEventListener("keydown", (e) => {
          if (e.key === "Escape") {
            closeOffcanvas();
            closeFarmlandDialog();
          }
        });

        if (recenterBtn) {
          recenterBtn.addEventListener("click", () => {
            centerView();
            closeOffcanvas();
          });
        }

        if (toggleStatsBtn) {
          toggleStatsBtn.addEventListener("click", () => {
            showStats = !showStats;
            updateStatsToggleUI();
            needsRender = true;
            saveState();
          });
        }

        function renderCropOptions() {
          if (!cropGrid) return;
          cropGrid.innerHTML = "";

          Object.values(crops).forEach((crop) => {
            const card = document.createElement("button");
            card.type = "button";

            let baseClass = "relative w-full aspect-square rounded-md overflow-hidden border text-left bg-neutral-900";
            if (crop.id === selectedCropKey) {
              baseClass += " border-emerald-500 ring-1 ring-emerald-500";
            } else {
              baseClass += " border-neutral-700 hover:border-neutral-500";
            }
            if (!crop.unlocked) {
              baseClass += " opacity-40 cursor-pointer";
            } else {
              baseClass += " cursor-pointer";
            }
            card.className = baseClass;

            const img = document.createElement("img");
            if (crop.id === "grass") {
              img.src = "images/grass.jpg";
            } else if (crop.id === "farmland") {
              img.src = "images/dirt.jpg";
            } else {
              img.src = `images/${crop.id}/${crop.id}-phase-4.png`;
            }
            img.alt = crop.name;
            img.className = "absolute inset-0 w-full h-full object-cover";
            if (!crop.unlocked) {
              img.className += " grayscale";
            }
            card.appendChild(img);

            const overlay = document.createElement("div");
            overlay.className = "relative z-10 h-full flex flex-col justify-end bg-gradient-to-t from-black/85 via-black/50 to-transparent p-2 text-[10px] space-y-0.5";

            if (crop.id === "grass") {
              overlay.innerHTML = `<div class="font-semibold text-xs text-white">${crop.name}</div>` + `<div class="text-neutral-200">Cost: Free</div>`;
            } else if (crop.id === "farmland") {
              const limitText = typeof crop.limit === "number" && crop.limit >= 0 ? crop.limit : "∞";

              const title = document.createElement("div");
              title.className = "font-semibold text-xs text-white";
              title.textContent = crop.name;
              overlay.appendChild(title);

              const costRow = document.createElement("div");
              costRow.className = "text-neutral-200";
              costRow.textContent = "Cost: Free";
              overlay.appendChild(costRow);

              const placedRow = document.createElement("div");
              placedRow.className = "mt-0.5 relative flex items-center text-neutral-200";

              const placedText = document.createElement("span");
              placedText.className = "pr-8 whitespace-nowrap";
              placedText.textContent = `Placed: ${crop.placed} of ${limitText}`;
              placedRow.appendChild(placedText);

              const plusBtn = document.createElement("button");
              plusBtn.type = "button";
              plusBtn.className =
                "absolute right-[-2px] top-1/2 -translate-y-1/2 " +
                "w-6 h-6 rounded-full border border-neutral-400 " +
                "bg-neutral-900 hover:bg-neutral-800 " +
                "flex items-center justify-center text-sm leading-none";
              plusBtn.textContent = "+";

              plusBtn.addEventListener("click", (e) => {
                e.stopPropagation();
                openFarmlandDialog();
              });

              placedRow.appendChild(plusBtn);
              overlay.appendChild(placedRow);
            } else {
              const plantCost = typeof crop.placeCost === "number" ? crop.placeCost : 0;
              const costText = plantCost > 0 ? `$${plantCost.toFixed(2)}` : "Free";

              overlay.innerHTML =
                `<div class="font-semibold text-xs text-white">${crop.name}</div>` +
                `<div class="text-neutral-200">Cost: ${costText}</div>` +
                `<div class="text-neutral-300">Grow time: ${crop.growMinutes} min</div>` +
                `<div class="text-neutral-200">Sell price: $${crop.baseValue.toFixed(2)}</div>`;

              if (!crop.unlocked && crop.unlockCost > 0) {
                overlay.innerHTML += `<div class="text-[9px] font-normal text-amber-300 mt-1">Unlock for: $${crop.unlockCost.toFixed(2)}</div>`;
              }
            }

            card.appendChild(overlay);

            card.addEventListener("click", () => {
              if (!crop.unlocked) {
                if (crop.unlockCost > 0 && totalMoney >= crop.unlockCost) {
                  totalMoney -= crop.unlockCost;
                  crop.unlocked = true;
                  selectedCropKey = crop.id;
                  previousCropKey = crop.id;
                  updateTotalDisplay();
                  renderCropOptions();
                  updateCurrentSelectionLabel();
                  saveState();
                }
                return;
              }

              selectedCropKey = crop.id;
              previousCropKey = crop.id;
              renderCropOptions();
              updateCurrentSelectionLabel();
              saveState();
            });

            cropGrid.appendChild(card);
          });
        }

        function renderStockOptions() {
          if (!stockGrid) return;
          stockGrid.innerHTML = "";
          Object.values(stocks).forEach((stock) => {
            const btn = document.createElement("button");
            btn.type = "button";
            let cls = "w-full aspect-square rounded-md border flex items-center justify-center text-[11px] font-semibold tracking-wide";
            if (stock.symbol === selectedStockKey) {
              cls += " border-emerald-500 bg-emerald-500/10";
            } else {
              cls += " border-neutral-700 bg-neutral-900 hover:bg-neutral-800";
            }
            btn.className = cls;
            btn.textContent = stock.symbol;
            btn.addEventListener("click", () => {
              selectedStockKey = stock.symbol;
              renderStockOptions();
              updateCurrentSelectionLabel();
              saveState();
            });
            stockGrid.appendChild(btn);
          });
        }

        function renderToolOptions() {
          if (!toolGrid) return;
          toolGrid.innerHTML = "";
          Object.values(tools).forEach((tool) => {
            const btn = document.createElement("button");
            btn.type = "button";
            let cls = "w-full aspect-square rounded-md border flex flex-col items-center justify-center text-[11px] font-semibold tracking-wide";
            if (tool.id === selectedToolKey) {
              cls += " border-emerald-500 bg-emerald-500/10";
            } else {
              cls += " border-neutral-700 bg-neutral-900 hover:bg-neutral-800";
            }
            if (!tool.unlocked) {
              cls += " opacity-50";
            }
            btn.className = cls;

            const label = document.createElement("div");
            label.textContent = tool.name;
            btn.appendChild(label);

            if (!tool.unlocked && tool.unlockCost > 0) {
              const cost = document.createElement("div");
              cost.className = "text-[9px] font-normal text-amber-300 mt-1";
              cost.textContent = `$${tool.unlockCost.toLocaleString()}`;
              btn.appendChild(cost);
            }

            btn.addEventListener("click", () => {
              if (!tool.unlocked) {
                if (tool.unlockCost > 0 && totalMoney >= tool.unlockCost) {
                  totalMoney -= tool.unlockCost;
                  tool.unlocked = true;
                  selectedToolKey = tool.id;
                  updateTotalDisplay();
                  renderToolOptions();
                  saveState();
                }
                return;
              }
              selectedToolKey = tool.id;
              renderToolOptions();
              saveState();
            });

            toolGrid.appendChild(btn);
          });
        }

        setInterval(() => {
          Object.values(stocks).forEach((s) => {
            const factor = 1 + (Math.random() - 0.5) * 0.01;
            s.price = Math.max(1, s.price * factor);
          });
          needsRender = true;
        }, 1000);

        updateTotalDisplay();
        renderCropOptions();
        renderStockOptions();
        renderToolOptions();
        updateCurrentSelectionLabel();
        resizeCanvas();
        updateStatsToggleUI();
        loop();
      })();
    </script>
  </body>
</html>
