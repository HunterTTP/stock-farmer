<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Stock Farmer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
      }
      body {
        display: flex;
        flex-direction: column;
        background-color: #000;
      }
      .action-error {
        position: fixed;
        z-index: 50;
        padding: 6px 10px;
        font-size: 11px;
        font-weight: 600;
        color: #fefefe;
        background: rgba(239, 68, 68, 0.95);
        border-radius: 8px;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
        pointer-events: none;
        transform: translate(-50%, -100%);
        max-width: 240px;
        text-align: center;
      }
      .canvas-wrapper {
        flex: 1 1 auto;
        position: relative;
        overflow: hidden;
      }
      #gridCanvas {
        width: 100%;
        height: 100%;
        display: block;
        touch-action: none;
        background-color: #000;
        user-select: none;
        -webkit-user-select: none;
        -ms-user-select: none;
        -webkit-touch-callout: none;
        -webkit-tap-highlight-color: transparent;
      }
      #cropStockStockLabel {
        display: block;
        width: 100%;
        text-align: center;
        line-height: 1.1;
      }
    </style>
  </head>
  <body class="bg-black text-white">
    <nav class="bg-neutral-900 text-white">
      <div class="flex items-center px-4 py-2 relative">
        <a class="text-sm font-semibold whitespace-nowrap" href="#">Stock Farmer</a>

        <div class="ml-auto flex items-center gap-2">
          <div id="totalDisplay" class="text-xs font-mono px-2 py-1 rounded bg-neutral-800">$0.00</div>
          <button
            id="navToggle"
            class="inline-flex items-center justify-center p-2 rounded-md border border-gray-500 hover:bg-neutral-800 focus:outline-none"
            type="button"
            aria-controls="navOffcanvas"
            aria-expanded="false">
            <span class="sr-only">Open controls</span>
            <svg class="h-4 w-4" viewBox="0 0 20 20" fill="none">
              <path d="M3 5h14M3 10h14M3 15h14" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" />
            </svg>
          </button>
        </div>
      </div>
    </nav>

    <div id="navOverlay" class="fixed inset-0 bg-black/50 hidden z-30"></div>

    <div id="navOffcanvas" class="fixed inset-y-0 right-0 w-64 bg-neutral-900 text-white shadow-xl transform translate-x-full transition-transform duration-200 z-40 flex flex-col">
      <div class="flex items-center justify-between px-4 py-3 border-b border-neutral-700">
        <h5 class="text-sm font-semibold" id="navOffcanvasLabel">Controls</h5>
        <button id="navClose" class="p-1 rounded-md hover:bg-neutral-800 focus:outline-none">
          <span class="sr-only">Close</span>
          <svg class="h-4 w-4" viewBox="0 0 20 20" fill="none" aria-hidden="true">
            <path d="M5 5l10 10M15 5L5 15" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" />
          </svg>
        </button>
      </div>
      <div class="flex-1 p-4 text-xs text-neutral-300 space-y-4 overflow-y-auto">
        <div>
          <p class="mb-2 font-medium text-neutral-200">Crop</p>
          <div id="cropGrid" class="grid grid-cols-2 gap-2"></div>
        </div>

        <div>
          <p class="mb-2 font-medium text-neutral-200">Stock</p>
          <div id="stockGrid" class="grid grid-cols-3 gap-2"></div>
        </div>

        <div class="flex items-center justify-between text-[11px]">
          <span class="text-neutral-200"></span>
          <button id="toggleStatsBtn" class="w-full border border-neutral-600 text-[11px] bg-neutral-800 px-2 py-2 rounded-md">Show Stats</button>
        </div>

        <button class="w-full border border-gray-500 text-xs px-3 py-2 rounded-md hover:bg-neutral-800 flex items-center justify-center text-center" id="recenterBtn">Recenter view</button>
        <button class="w-full border border-red-700 text-xs px-3 py-2 rounded-md hover:bg-red-800/80 bg-red-800/40 flex items-center justify-center text-center mt-2" id="resetFarmBtn">
          Reset farm
        </button>
      </div>
    </div>

    <div id="confirmModal" class="fixed inset-0 z-50 bg-black/70 backdrop-blur-sm flex items-center justify-center px-3 py-6 hidden">
      <div class="w-full max-w-sm bg-neutral-900 border border-neutral-800 rounded-lg shadow-2xl overflow-hidden">
        <div class="flex items-center justify-between px-4 py-3 border-b border-neutral-800">
          <h3 id="confirmTitle" class="text-sm font-semibold text-white">Confirm</h3>
          <button id="confirmClose" class="p-1 rounded-md hover:bg-neutral-800 focus:outline-none">
            <span class="sr-only">Close</span>
            <svg class="h-4 w-4" viewBox="0 0 20 20" fill="none" aria-hidden="true">
              <path d="M5 5l10 10M15 5L5 15" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" />
            </svg>
          </button>
        </div>
        <div id="confirmMessage" class="px-4 py-4 text-sm text-neutral-100 leading-relaxed"></div>
        <div class="px-4 pb-4 flex gap-2">
          <button id="confirmConfirm" class="w-1/2 py-2 rounded-md bg-emerald-600 text-white text-sm font-semibold hover:bg-emerald-500 focus:outline-none">Yes</button>
          <button id="confirmCancel" class="w-1/2 py-2 rounded-md border border-red-700 bg-red-700/70 text-white text-sm font-medium hover:bg-red-600 focus:outline-none">No</button>
        </div>
      </div>
    </div>

    <div class="canvas-wrapper">
      <canvas id="gridCanvas"></canvas>
      <div class="pointer-events-none absolute inset-x-0 bottom-2 px-3 flex justify-center z-20">
        <div class="pointer-events-auto w-full max-w-xl">
          <div class="flex items-stretch justify-center gap-2 flex-wrap">
            <button
              id="cropStockButton"
              class="flex-shrink-0 border border-neutral-700 rounded-md bg-neutral-900 hover:bg-neutral-800 flex items-center gap-2 px-3 py-2 text-[11px] font-semibold tracking-wide shadow-lg">
              <div class="w-10 h-10 rounded border border-neutral-700 overflow-hidden bg-neutral-800 flex-shrink-0">
                <img id="cropStockImage" class="w-full h-full object-cover" alt="Crop" />
              </div>
              <div id="cropStockStockWrapper" class="w-10 h-10 rounded border border-neutral-700 bg-neutral-800 flex items-center justify-center text-[11px] font-semibold text-white">
                <span id="cropStockStockLabel"></span>
              </div>
            </button>
            <button
              id="hoeButton"
              class="w-12 border border-neutral-700 rounded-md bg-neutral-900 hover:bg-neutral-800 flex items-center justify-center shadow-lg"
              aria-label="Toggle hoe"
              aria-pressed="false">
              <img src="images/hoe/hoe-phase-1.png" alt="Hoe" class="w-7 h-7 object-contain pointer-events-none" />
            </button>
            <div class="relative">
              <button
                id="sizeButton"
                class="h-full border border-neutral-700 rounded-md bg-neutral-900 hover:bg-neutral-800 px-3 py-2 text-[11px] font-semibold tracking-wide flex items-center gap-2 shadow-lg">
                <span id="sizeButtonLabel" class="text-white"></span>
                <svg class="w-3 h-3 text-neutral-400" viewBox="0 0 16 16" fill="none" aria-hidden="true">
                  <path d="M3 6l5 5 5-5" stroke="currentColor" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round" />
                </svg>
              </button>
              <div id="sizeMenu" class="hidden absolute bottom-full mb-2 right-0 min-w-[140px] bg-neutral-900 border border-neutral-700 rounded-md shadow-2xl overflow-hidden"></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      (() => {
        "use strict";

        const canvas = document.getElementById("gridCanvas");
        if (!canvas) return;
        const ctx = canvas.getContext("2d");

        const config = {
          gridCols: 100,
          gridRows: 100,
          baseTileSize: 100,
          visibleRowsAtStart: 3,
          minScale: 0.05,
          maxScale: 3,
          hoeDestroyWindowMs: 350,
          saveKey: "stockFarmerState",
          defaultFilled: ["49,49", "49,50", "50,49", "50,50"],
        };

        const crops = {
          grass: { id: "grass", name: "Grass", growMinutes: 0, baseValue: 0, unlocked: true, unlockCost: 0, images: [], limit: -1, placed: 0 },
          farmland: { id: "farmland", name: "Farmland", growMinutes: 0, baseValue: 0, unlocked: true, unlockCost: 0, images: [], limit: -1, placed: 0 },
          wheat: { id: "wheat", name: "Wheat", growMinutes: 1, baseValue: 1, unlocked: true, unlockCost: 0, images: [], limit: -1, placed: 0 },
          carrot: { id: "carrot", name: "Carrot", growMinutes: 2.5, baseValue: 5, unlocked: false, unlockCost: 100, placeCost: 2.5, images: [], limit: -1, placed: 0 },
          potato: { id: "potato", name: "Potato", growMinutes: 5, baseValue: 10, unlocked: false, unlockCost: 1000, placeCost: 5, images: [], limit: -1, placed: 0 },
        };

        const stocks = {
          SP500: { symbol: "SP500", name: "S&P 500", price: 100 },
          AMZN: { symbol: "AMZN", name: "AMZN", price: 100 },
          TSLA: { symbol: "TSLA", name: "TSLA", price: 100 },
        };

        const sizes = {
          single: { id: "single", name: "1x1", size: 1, unlocked: true, unlockCost: 0 },
          square2: { id: "square2", name: "2x2", size: 2, unlocked: false, unlockCost: 1000 },
          square3: { id: "square3", name: "3x3", size: 3, unlocked: false, unlockCost: 25000 },
          square5: { id: "square5", name: "5x5", size: 5, unlocked: false, unlockCost: 100000 },
        };

        const state = {
          tileSize: config.baseTileSize,
          offsetX: 0,
          offsetY: 0,
          scale: 1,
          defaultScale: 1,
          dragStart: { x: 0, y: 0 },
          dragOffsetStart: { x: 0, y: 0 },
          isDragging: false,
          activePointers: new Map(),
          isPinching: false,
          pinchStartDistance: 0,
          pinchStartScale: 1,
          pinchCenter: { x: 0, y: 0 },
          tapStart: null,
          hoverTile: null,
          needsRender: true,
          firstResizeDone: false,
          savedScaleFromState: null,
          scaleDirty: false,
          totalMoney: 0,
          showStats: true,
          selectedCropKey: "wheat",
          previousCropKey: "wheat",
          selectedStockKey: "SP500",
          selectedSizeKey: "single",
          hoeSelected: false,
          hoeHoldTimeoutId: null,
          hoeHoldTriggered: false,
        };

        const world = {
          plots: new Map(),
          filled: new Set(config.defaultFilled),
          harvestAnimations: [],
          costAnimations: [],
        };

        const assets = {
          farmland: { img: new Image(), loaded: false },
          grass: { img: new Image(), loaded: false },
        };

        assets.farmland.img.src = "images/farmland.jpg";
        assets.farmland.img.onload = () => {
          assets.farmland.loaded = true;
          state.needsRender = true;
        };

        assets.grass.img.src = "images/grass.jpg";
        assets.grass.img.onload = () => {
          assets.grass.loaded = true;
          state.needsRender = true;
        };

        Object.values(crops)
          .filter((c) => c.id !== "grass" && c.id !== "farmland")
          .forEach((crop) => {
            crop.growTimeMs = crop.growMinutes * 60 * 1000;
            crop.images = Array.from({ length: 4 }, (_, i) => {
              const img = new Image();
              img.src = `images/${crop.id}/${crop.id}-phase-${i + 1}.png`;
              img.onload = () => (state.needsRender = true);
              return img;
            });
          });

        const dom = {
          totalDisplay: document.getElementById("totalDisplay"),
          navToggle: document.getElementById("navToggle"),
          navOffcanvas: document.getElementById("navOffcanvas"),
          navOverlay: document.getElementById("navOverlay"),
          navClose: document.getElementById("navClose"),
          recenterBtn: document.getElementById("recenterBtn"),
          cropGrid: document.getElementById("cropGrid"),
          stockGrid: document.getElementById("stockGrid"),
          hoeButton: document.getElementById("hoeButton"),
          cropStockButton: document.getElementById("cropStockButton"),
          cropStockImage: document.getElementById("cropStockImage"),
          cropStockStockLabel: document.getElementById("cropStockStockLabel"),
          cropStockStockWrapper: document.getElementById("cropStockStockWrapper"),
          sizeButton: document.getElementById("sizeButton"),
          sizeButtonLabel: document.getElementById("sizeButtonLabel"),
          sizeMenu: document.getElementById("sizeMenu"),
          resetFarmBtn: document.getElementById("resetFarmBtn"),
          toggleStatsBtn: document.getElementById("toggleStatsBtn"),
          confirmModal: document.getElementById("confirmModal"),
          confirmMessage: document.getElementById("confirmMessage"),
          confirmCancel: document.getElementById("confirmCancel"),
          confirmConfirm: document.getElementById("confirmConfirm"),
          confirmClose: document.getElementById("confirmClose"),
          confirmTitle: document.getElementById("confirmTitle"),
        };

        let pendingConfirmAction = null;
        let sizeMenuVisible = false;

        loadState();
        if (!localStorage.getItem(config.saveKey)) {
          applyDefaultSelection();
        }
        recalcPlacedCounts();
        bindUI();
        refreshAllUI();
        resizeCanvas();
        loop();
        setInterval(updateStockPrices, 1000);

        function applyDefaultSelection() {
          state.selectedCropKey = "wheat";
          state.previousCropKey = "wheat";
          state.selectedStockKey = "SP500";
          state.selectedSizeKey = "single";
          state.hoeSelected = false;
        }

        function bindUI() {
          canvas.addEventListener("pointerdown", onPointerDown);
          canvas.addEventListener("pointermove", onPointerMove);
          canvas.addEventListener("pointerup", onPointerUp);
          canvas.addEventListener("pointercancel", onPointerUp);
          canvas.addEventListener("pointerleave", onPointerUp);
          canvas.addEventListener("wheel", onWheel, { passive: false });

          window.addEventListener("resize", () => {
            resizeCanvas();
            state.needsRender = true;
          });

          if (dom.navToggle) dom.navToggle.addEventListener("click", toggleOffcanvas);
          if (dom.navClose) dom.navClose.addEventListener("click", closeOffcanvas);
          if (dom.navOverlay) dom.navOverlay.addEventListener("click", closeOffcanvas);

          document.addEventListener("keydown", (e) => {
            if (e.key === "Escape") {
              closeConfirmModal();
              closeOffcanvas();
            }
          });

          if (dom.recenterBtn) {
            dom.recenterBtn.addEventListener("click", () => {
              centerView();
              closeOffcanvas();
            });
          }

          if (dom.confirmCancel) dom.confirmCancel.addEventListener("click", closeConfirmModal);
          if (dom.confirmClose) dom.confirmClose.addEventListener("click", closeConfirmModal);
          if (dom.confirmConfirm) {
            dom.confirmConfirm.addEventListener("click", () => {
              if (pendingConfirmAction) pendingConfirmAction();
              closeConfirmModal();
            });
          }

          if (dom.toggleStatsBtn) {
            dom.toggleStatsBtn.addEventListener("click", () => {
              state.showStats = !state.showStats;
              updateStatsToggleUI();
              state.needsRender = true;
              saveState();
            });
          }

          if (dom.resetFarmBtn) {
            dom.resetFarmBtn.addEventListener("click", () => {
              openConfirmModal("Reset your farm and start fresh? This clears all progress.", resetFarm, "Reset Farm");
            });
          }

          if (dom.hoeButton) {
            dom.hoeButton.addEventListener("click", () => {
              state.hoeSelected = !state.hoeSelected;
              updateModeButtonsUI();
              state.needsRender = true;
              saveState();
            });
          }

          if (dom.cropStockButton) {
            dom.cropStockButton.addEventListener("click", () => {
              state.hoeSelected = false;
              if (!state.selectedCropKey) {
                const firstUnlocked = Object.values(crops).find((c) => c && c.unlocked);
                if (firstUnlocked) {
                  state.selectedCropKey = firstUnlocked.id;
                  state.previousCropKey = firstUnlocked.id;
                }
              }
              updateModeButtonsUI();
              state.needsRender = true;
              saveState();
            });
          }

          if (dom.sizeButton) {
            dom.sizeButton.addEventListener("click", (e) => {
              e.stopPropagation();
              if (sizeMenuVisible) {
                closeSizeMenu();
              } else {
                renderSizeMenu();
                dom.sizeMenu?.classList.remove("hidden");
                sizeMenuVisible = true;
              }
            });
          }

          document.addEventListener("click", (e) => {
            if (!sizeMenuVisible) return;
            if (dom.sizeMenu && (dom.sizeMenu.contains(e.target) || (dom.sizeButton && dom.sizeButton.contains(e.target)))) return;
            closeSizeMenu();
          });

          document.addEventListener("pointerleave", () => {
            if (state.hoeHoldTimeoutId) {
              clearTimeout(state.hoeHoldTimeoutId);
              state.hoeHoldTimeoutId = null;
            }
          });
        }

        function refreshAllUI() {
          onMoneyChanged();
          renderStockOptions();
          updateCropStockButtonUI();
          updateSizeButtonUI();
          renderSizeMenu();
          updateModeButtonsUI();
          updateStatsToggleUI();
        }

        function currentSizeOption() {
          return sizes[state.selectedSizeKey] || sizes.single;
        }

        function cropImageSrc(cropId) {
          if (cropId === "grass") return "images/grass.jpg";
          if (cropId === "farmland") return "images/farmland.jpg";
          if (cropId) return `images/${cropId}/${cropId}-phase-4.png`;
          return "images/grass.jpg";
        }

        function createRandomStageBreakpoints() {
          const a = Math.random() * 0.6 + 0.1;
          const b = Math.random() * 0.2 + 0.75;
          return [Math.min(a, b - 0.05), b];
        }

        function formatCurrency(amount, allowCents = true) {
          const rounded = Math.round(amount * 100) / 100;
          const hasCents = allowCents && Math.abs(rounded - Math.round(rounded)) > 0.0001;
          if (hasCents) return "$" + rounded.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
          return "$" + Math.round(rounded).toLocaleString();
        }

        function updateTotalDisplay() {
          if (dom.totalDisplay) dom.totalDisplay.textContent = formatCurrency(state.totalMoney, true);
        }

        function onMoneyChanged() {
          updateTotalDisplay();
          renderCropOptions();
          renderSizeMenu();
        }
        function saveState() {
          const data = {
            totalMoney: state.totalMoney,
            filled: Array.from(world.filled),
            plots: Array.from(world.plots.entries()),
            selectedCropKey: state.selectedCropKey,
            previousCropKey: state.previousCropKey,
            selectedStockKey: state.selectedStockKey,
            selectedSizeKey: state.selectedSizeKey,
            hoeSelected: state.hoeSelected,
            showStats: state.showStats,
            scale: state.scale,
            cropsUnlocked: Object.fromEntries(Object.entries(crops).map(([id, c]) => [id, c.unlocked])),
            sizesUnlocked: Object.fromEntries(Object.entries(sizes).map(([id, t]) => [id, t.unlocked])),
            cropLimits: Object.fromEntries(Object.entries(crops).map(([id, c]) => [id, typeof c.limit === "number" ? c.limit : -1])),
          };
          try {
            localStorage.setItem(config.saveKey, JSON.stringify(data));
          } catch (err) {
            console.error("Failed to save state", err);
          }
        }

        function loadState() {
          let raw;
          try {
            raw = localStorage.getItem(config.saveKey);
          } catch (err) {
            console.error("Failed to read state", err);
            return;
          }
          if (!raw) return;
          try {
            const data = JSON.parse(raw);
            if (typeof data.totalMoney === "number") state.totalMoney = data.totalMoney;

            if (Array.isArray(data.filled)) {
              world.filled.clear();
              data.filled.forEach((k) => world.filled.add(k));
            }

            if (Array.isArray(data.plots)) {
              world.plots.clear();
              data.plots.forEach(([key, value]) => {
                world.plots.set(key, value);
              });
            }

            if (data.cropsUnlocked) {
              Object.entries(data.cropsUnlocked).forEach(([id, unlocked]) => {
                if (crops[id]) crops[id].unlocked = !!unlocked;
              });
            }

            const sizeUnlockData = data.sizesUnlocked || data.toolsUnlocked;
            if (sizeUnlockData) {
              Object.entries(sizeUnlockData).forEach(([id, unlocked]) => {
                if (sizes[id]) sizes[id].unlocked = !!unlocked;
              });
            }

            if (data.cropLimits) {
              Object.entries(data.cropLimits).forEach(([id, limit]) => {
                if (crops[id] && typeof limit === "number") crops[id].limit = limit;
              });
            }

            if (Object.prototype.hasOwnProperty.call(data, "selectedCropKey")) {
              if (data.selectedCropKey && crops[data.selectedCropKey]) state.selectedCropKey = data.selectedCropKey;
              else if (data.selectedCropKey === null) state.selectedCropKey = null;
            }

            if (data.previousCropKey && crops[data.previousCropKey]) state.previousCropKey = data.previousCropKey;
            if (data.selectedStockKey && stocks[data.selectedStockKey]) state.selectedStockKey = data.selectedStockKey;
            if (data.selectedSizeKey && sizes[data.selectedSizeKey]) state.selectedSizeKey = data.selectedSizeKey;
            else if (data.selectedToolKey && sizes[data.selectedToolKey]) state.selectedSizeKey = data.selectedToolKey;

            if (typeof data.showStats === "boolean") state.showStats = data.showStats;
            if (typeof data.hoeSelected === "boolean") state.hoeSelected = data.hoeSelected;
            if (typeof data.scale === "number") state.savedScaleFromState = data.scale;

            if (!state.hoeSelected && state.selectedCropKey && crops[state.selectedCropKey]) {
              state.previousCropKey = state.selectedCropKey;
            }

            state.needsRender = true;
          } catch (err) {
            console.error("State load failed", err);
          }
        }

        function recalcPlacedCounts() {
          Object.values(crops).forEach((c) => {
            c.placed = 0;
          });
          if (crops.farmland) {
            crops.farmland.placed = world.filled.size;
          }
          world.plots.forEach((plot) => {
            const crop = crops[plot.cropKey];
            if (crop) crop.placed += 1;
          });
        }

        function centerView() {
          const rect = canvas.getBoundingClientRect();
          const worldWidth = config.gridCols * state.tileSize;
          const worldHeight = config.gridRows * state.tileSize;
          const canvasWidth = rect.width;
          const canvasHeight = rect.height;
          const worldCenterX = worldWidth / 2;
          const worldCenterY = worldHeight / 2;
          const canvasCenterX = canvasWidth / 2;
          const canvasCenterY = canvasHeight / 2;
          state.offsetX = canvasCenterX - worldCenterX * state.scale;
          state.offsetY = canvasCenterY - worldCenterY * state.scale;
          state.needsRender = true;
        }

        function resizeCanvas() {
          const rect = canvas.getBoundingClientRect();
          const dpr = window.devicePixelRatio || 1;
          canvas.width = rect.width * dpr;
          canvas.height = rect.height * dpr;
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

          const scaleFromHeight = rect.height / (config.visibleRowsAtStart * state.tileSize);
          const scaleFromWidth = rect.width / (config.visibleRowsAtStart * state.tileSize);
          const initialScale = Math.min(scaleFromHeight, scaleFromWidth);

          if (!state.firstResizeDone) {
            const targetScale = state.savedScaleFromState != null ? clampScale(state.savedScaleFromState) : initialScale;
            state.scale = targetScale;
            state.defaultScale = targetScale;
            state.firstResizeDone = true;
          }
          centerView();
        }

        function clampScale(s) {
          return Math.min(config.maxScale, Math.max(config.minScale, s));
        }

        function zoomAt(factor, cx, cy) {
          const newScale = clampScale(state.scale * factor);
          const k = newScale / state.scale;
          state.offsetX = cx - (cx - state.offsetX) * k;
          state.offsetY = cy - (cy - state.offsetY) * k;
          state.scale = newScale;
          state.scaleDirty = true;
          state.needsRender = true;
          saveState();
          state.scaleDirty = false;
        }

        function renderFloatingValue(anim, nowPerf, startRow, endRow, startCol, endCol) {
          const visibleDuration = 1000;
          const fadeDuration = 500;
          const totalDuration = visibleDuration + fadeDuration;
          const elapsed = nowPerf - anim.start;
          if (elapsed >= totalDuration) return true;

          const [rowStr, colStr] = anim.key.split(",");
          const row = parseInt(rowStr, 10);
          const col = parseInt(colStr, 10);
          if (Number.isNaN(row) || Number.isNaN(col)) return false;
          if (row < startRow || row >= endRow || col < startCol || col >= endCol) return false;

          const cellX = state.offsetX + col * state.tileSize * state.scale;
          const cellY = state.offsetY + row * state.tileSize * state.scale;
          const cx = cellX + (state.tileSize * state.scale) / 2;
          const cy = cellY + (state.tileSize * state.scale) / 2;

          let alpha;
          if (elapsed <= visibleDuration) {
            alpha = 1;
          } else {
            const fadeT = (elapsed - visibleDuration) / fadeDuration;
            alpha = 1 - Math.min(1, Math.max(0, fadeT));
          }

          const value = anim.value;
          const isPositiveOrZero = value >= 0;
          const absValue = Math.abs(value);
          const prefix = isPositiveOrZero ? "+$" : "-$";
          const cellScreenSize = state.tileSize * state.scale;
          const fontSize = cellScreenSize * 0.22;

          ctx.save();
          ctx.globalAlpha = alpha;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.font = `700 ${fontSize}px system-ui`;
          ctx.shadowColor = "rgba(0,0,0,0.3)";
          ctx.shadowBlur = cellScreenSize * 0.05;
          ctx.shadowOffsetX = 0;
          ctx.shadowOffsetY = cellScreenSize * 0.015;
          ctx.fillStyle = isPositiveOrZero ? "#22c55e" : "#ef4444";
          ctx.fillText(prefix + absValue.toFixed(2), cx, cy);
          ctx.restore();
          return false;
        }

        function render() {
          const hasAnimations = world.harvestAnimations.length > 0 || world.costAnimations.length > 0;
          if (!state.needsRender && !hasAnimations) return;
          state.needsRender = false;

          const width = canvas.clientWidth;
          const height = canvas.clientHeight;
          ctx.clearRect(0, 0, width, height);
          if (!assets.farmland.loaded || !assets.grass.loaded) return;

          const worldLeft = -state.offsetX / state.scale;
          const worldRight = (width - state.offsetX) / state.scale;
          const worldTop = -state.offsetY / state.scale;
          const worldBottom = (height - state.offsetY) / state.scale;

          const startCol = Math.max(0, Math.floor(worldLeft / state.tileSize));
          const endCol = Math.min(config.gridCols, Math.ceil(worldRight / state.tileSize));
          const startRow = Math.max(0, Math.floor(worldTop / state.tileSize));
          const endRow = Math.min(config.gridRows, Math.ceil(worldBottom / state.tileSize));

          const tileScreenSize = state.tileSize * state.scale;
          const isZoomedOut = tileScreenSize < 72;
          const now = Date.now();
          const nowPerf = performance.now();

          for (let row = startRow; row < endRow; row++) {
            for (let col = startCol; col < endCol; col++) {
              const key = row + "," + col;
              const x = state.offsetX + col * state.tileSize * state.scale;
              const y = state.offsetY + row * state.tileSize * state.scale;

              if (world.filled.has(key)) ctx.drawImage(assets.farmland.img, x, y, tileScreenSize, tileScreenSize);
              else ctx.drawImage(assets.grass.img, x, y, tileScreenSize, tileScreenSize);

              const plot = world.plots.get(key);
              if (!plot) continue;
              const crop = crops[plot.cropKey];
              const stock = stocks[plot.stockKey];
              if (!crop || !stock || !crop.images.length) continue;

              const elapsed = now - plot.plantedAt;
              const progress = Math.min(1, elapsed / crop.growTimeMs);
              const isReady = progress >= 1;
              if (isReady && plot.lockedStockPrice == null) {
                plot.lockedStockPrice = stock.price;
                saveState();
              }

              const breakpoints = Array.isArray(plot.stageBreakpoints) && plot.stageBreakpoints.length === 2 ? plot.stageBreakpoints : [1 / 3, 2 / 3];
              let phaseIndex = 0;
              if (isReady) phaseIndex = 3;
              else if (progress >= breakpoints[1]) phaseIndex = 2;
              else if (progress >= breakpoints[0]) phaseIndex = 1;

              const img = crop.images[phaseIndex] || crop.images[crop.images.length - 1];
              const effectivePrice = isReady && plot.lockedStockPrice != null ? plot.lockedStockPrice : stock.price;
              const pctChange = (effectivePrice - plot.stockPriceAtPlant) / plot.stockPriceAtPlant;
              const value = Math.max(0, crop.baseValue * (1 + pctChange));
              const pctText = `${pctChange >= 0 ? "+" : ""}${(pctChange * 100).toFixed(1)}%`;
              const valueText = "$" + value.toFixed(2);

              const remainingMs = Math.max(0, crop.growTimeMs - elapsed);
              const secs = Math.ceil(remainingMs / 1000);
              const mins = Math.floor(secs / 60);
              const secPart = secs % 60;
              const timerText = mins + ":" + secPart.toString().padStart(2, "0");

              let arrow = "";
              if (pctChange > 0) arrow = "^";
              else if (pctChange < 0) arrow = "v";

              let stockColor = "white";
              if (pctChange > 0) stockColor = "#22c55e";
              else if (pctChange < 0) stockColor = "#ef4444";

              ctx.drawImage(img, x, y, tileScreenSize, tileScreenSize);

              if (isZoomedOut) {
                if (state.showStats && !isReady) {
                  ctx.fillStyle = "rgba(0,0,0,0.7)";
                  ctx.fillRect(x, y, tileScreenSize, tileScreenSize);

                  ctx.save();
                  ctx.textAlign = "left";
                  ctx.textBaseline = "top";
                  const pad = tileScreenSize * 0.08;
                  let lineY = y + pad;
                  const baseX = x + pad;
                  ctx.font = `${tileScreenSize * 0.22}px system-ui`;
                  ctx.fillStyle = stockColor;
                  ctx.fillText(`${plot.stockKey} ${arrow}`, baseX, lineY);
                  lineY += tileScreenSize * 0.24;
                  ctx.font = `${tileScreenSize * 0.2}px system-ui`;
                  ctx.fillStyle = "white";
                  ctx.fillText(pctText, baseX, lineY);
                  lineY += tileScreenSize * 0.2;
                  ctx.fillText(valueText, baseX, lineY);
                  lineY += tileScreenSize * 0.2;
                  ctx.fillText(timerText, baseX, lineY);
                  ctx.restore();
                }
                continue;
              }

              const pad = 3 * state.scale;
              const infoHeight = 32 * state.scale;
              if (state.showStats && !isReady) {
                ctx.fillStyle = "rgba(0,0,0,0.65)";
                ctx.fillRect(x, y, tileScreenSize, infoHeight);
                ctx.textBaseline = "top";
                ctx.font = `${9 * state.scale}px system-ui`;
                const baseX = x + pad;
                const baseY = y + pad;
                const tickerText = `${plot.stockKey} ${arrow}`;
                ctx.fillStyle = stockColor;
                ctx.fillText(tickerText, baseX, baseY);
                const tickerWidth = ctx.measureText(tickerText + " ").width;
                ctx.fillStyle = "white";
                ctx.fillText(pctText, baseX + tickerWidth, baseY);
                ctx.fillText(valueText, baseX, baseY + 10 * state.scale);
                ctx.fillText(timerText, baseX, baseY + 20 * state.scale);
              }
            }
          }

          for (let i = world.harvestAnimations.length - 1; i >= 0; i--) {
            const done = renderFloatingValue(world.harvestAnimations[i], nowPerf, startRow, endRow, startCol, endCol);
            if (done) world.harvestAnimations.splice(i, 1);
          }
          for (let i = world.costAnimations.length - 1; i >= 0; i--) {
            const done = renderFloatingValue(world.costAnimations[i], nowPerf, startRow, endRow, startCol, endCol);
            if (done) world.costAnimations.splice(i, 1);
          }
          if (world.harvestAnimations.length || world.costAnimations.length) state.needsRender = true;

          ctx.strokeStyle = "rgba(30,30,30,0.9)";
          ctx.lineWidth = Math.max(0.5, state.scale * 0.4);
          ctx.beginPath();
          for (let col = startCol; col <= endCol; col++) {
            const x = state.offsetX + col * state.tileSize * state.scale;
            ctx.moveTo(x, state.offsetY + startRow * state.tileSize * state.scale);
            ctx.lineTo(x, state.offsetY + endRow * state.tileSize * state.scale);
          }
          for (let row = startRow; row <= endRow; row++) {
            const y = state.offsetY + row * state.tileSize * state.scale;
            ctx.moveTo(state.offsetX + startCol * state.tileSize * state.scale, y);
            ctx.lineTo(state.offsetX + endCol * state.tileSize * state.scale, y);
          }
          ctx.stroke();

          if (state.hoverTile) {
            const sizeOption = currentSizeOption();
            const size = Math.max(1, sizeOption.size || 1);
            const preview = computeHoverPreview(state.hoverTile.row, state.hoverTile.col, size, now);
            const allowedColor = "rgba(34,197,94,0.75)";
            const blockedColor = "rgba(239,68,68,0.75)";
            ctx.lineWidth = Math.max(1.2, state.scale * 0.9);
            for (const cell of preview) {
              const { row, col, allowed } = cell;
              if (row < startRow || row >= endRow || col < startCol || col >= endCol) continue;
              const x = state.offsetX + col * state.tileSize * state.scale;
              const y = state.offsetY + row * state.tileSize * state.scale;
              ctx.strokeStyle = allowed ? allowedColor : blockedColor;
              ctx.strokeRect(x, y, state.tileSize * state.scale, state.tileSize * state.scale);
            }
          }
        }

        function loop() {
          render();
          requestAnimationFrame(loop);
        }

        function updatePointer(e) {
          state.activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
        }

        function getTwoPointers() {
          const vals = Array.from(state.activePointers.values());
          return vals.length >= 2 ? [vals[0], vals[1]] : null;
        }

        function worldFromClient(clientX, clientY) {
          const rect = canvas.getBoundingClientRect();
          const x = clientX - rect.left;
          const y = clientY - rect.top;
          const worldX = (x - state.offsetX) / state.scale;
          const worldY = (y - state.offsetY) / state.scale;
          return { worldX, worldY };
        }

        function tileFromClient(clientX, clientY) {
          const { worldX, worldY } = worldFromClient(clientX, clientY);
          const col = Math.floor(worldX / state.tileSize);
          const row = Math.floor(worldY / state.tileSize);
          if (row < 0 || row >= config.gridRows || col < 0 || col >= config.gridCols) return null;
          return { row, col, key: row + "," + col };
        }

        function setHoverTile(tile) {
          const same = state.hoverTile && tile && state.hoverTile.row === tile.row && state.hoverTile.col === tile.col;
          if (same) return;
          if (!state.hoverTile && !tile) return;
          state.hoverTile = tile;
          state.needsRender = true;
        }

        function updateHoverFromEvent(e) {
          if (state.isDragging || state.isPinching) {
            setHoverTile(null);
            return;
          }
          const tile = tileFromClient(e.clientX, e.clientY);
          setHoverTile(tile ? { row: tile.row, col: tile.col } : null);
        }
        function determineActionForTile(row, col, nowMs = Date.now()) {
          if (row < 0 || col < 0 || row >= config.gridRows || col >= config.gridCols) return { type: "none", reason: "Out of bounds" };
          const key = row + "," + col;
          const existingPlot = world.plots.get(key);
          if (state.hoeSelected) {
            if (existingPlot) {
              const crop = crops[existingPlot.cropKey];
              if (crop && nowMs - existingPlot.plantedAt >= crop.growTimeMs) return { type: "harvest" };
              return { type: "none", reason: "Not ready to harvest" };
            }
            return { type: "none", reason: "Nothing to harvest" };
          }

          if (existingPlot) return { type: "none", reason: "Already planted" };
          const cropSelection = state.selectedCropKey ? crops[state.selectedCropKey] : null;
          if (!cropSelection) return { type: "none", reason: "Select a crop" };
          if (cropSelection.id === "grass") return { type: "removeFarmland" };
          if (cropSelection.id === "farmland") {
            const farmlandCrop = crops.farmland;
            if (!farmlandCrop) return { type: "none", reason: "Missing farmland crop" };
            if (world.plots.has(key) || world.filled.has(key)) return { type: "none", reason: "Tile occupied" };
            const cost = farmlandCrop.placed < 4 ? 0 : 25;
            if (cost > 0 && state.totalMoney < cost) return { type: "none", reason: "Not enough money" };
            return { type: "placeFarmland" };
          }

          const crop = cropSelection;
          const stock = stocks[state.selectedStockKey];
          if (!crop || !crop.unlocked) return { type: "none", reason: "Crop locked" };
          if (!stock) return { type: "none", reason: "Select a stock" };
          if (!world.filled.has(key)) return { type: "none", reason: "Need farmland first" };
          if (typeof crop.limit === "number" && crop.limit >= 0 && crop.placed >= crop.limit) return { type: "none", reason: "Crop limit reached" };
          const plantCost = typeof crop.placeCost === "number" ? crop.placeCost : 0;
          if (plantCost > 0 && state.totalMoney < plantCost) return { type: "none", reason: "Not enough money" };
          return { type: "plantCrop", cropKey: cropSelection.id, stockKey: state.selectedStockKey };
        }

        function computeHoverPreview(baseRow, baseCol, size, nowMs) {
          const results = [];
          const baseAction = state.hoeSelected ? null : determineActionForTile(baseRow, baseCol, nowMs);
          const placed = {};
          Object.values(crops).forEach((c) => {
            placed[c.id] = typeof c.placed === "number" ? Math.max(0, c.placed) : 0;
          });
          const previewState = { money: state.totalMoney, placed, filledAdds: new Set(), filledRemovals: new Set(), plotsRemoved: new Set() };
          const getFilled = (key) => {
            if (previewState.filledAdds.has(key)) return true;
            if (previewState.filledRemovals.has(key)) return false;
            return world.filled.has(key);
          };
          const getPlot = (key) => {
            if (previewState.plotsRemoved.has(key)) return null;
            return world.plots.get(key) || null;
          };
          for (let dr = 0; dr < size; dr++) {
            for (let dc = 0; dc < size; dc++) {
              const row = baseRow + dr;
              const col = baseCol + dc;
              const key = row + "," + col;
              let allowed = false;
              if (row < 0 || row >= config.gridRows || col < 0 || col >= config.gridCols) {
                results.push({ row, col, allowed });
                continue;
              }
              const actionForCell = state.hoeSelected ? determineActionForTile(row, col, nowMs) : baseAction;
              allowed = simulateTileActionForPreview(actionForCell, key, previewState, nowMs, getFilled, getPlot);
              results.push({ row, col, allowed });
            }
          }
          return results;
        }

        function simulateTileActionForPreview(action, key, previewState, nowMs, getFilled, getPlot) {
          if (!action || action.type === "none") return false;
          switch (action.type) {
            case "harvest": {
              const existingPlot = getPlot(key);
              const plotCrop = existingPlot ? crops[existingPlot.cropKey] : null;
              const plotStock = existingPlot ? stocks[existingPlot.stockKey] : null;
              if (!existingPlot || !plotCrop || !plotStock) return false;
              const ready = nowMs - existingPlot.plantedAt >= plotCrop.growTimeMs;
              if (!ready) return false;
              const effectivePrice = existingPlot.lockedStockPrice != null ? existingPlot.lockedStockPrice : plotStock.price;
              const pctChange = (effectivePrice - existingPlot.stockPriceAtPlant) / existingPlot.stockPriceAtPlant;
              const value = Math.max(0, plotCrop.baseValue * (1 + pctChange));
              previewState.money += value;
              if (typeof previewState.placed[plotCrop.id] === "number" && previewState.placed[plotCrop.id] > 0) previewState.placed[plotCrop.id] -= 1;
              previewState.plotsRemoved.add(key);
              return true;
            }
            case "removeFarmland": {
              if (getFilled(key)) {
                previewState.filledRemovals.add(key);
                if (typeof previewState.placed.farmland === "number" && previewState.placed.farmland > 0) previewState.placed.farmland -= 1;
                return true;
              }
              return false;
            }
            case "placeFarmland": {
              if (getFilled(key) || getPlot(key)) return false;
              const farmlandPlaced = typeof previewState.placed.farmland === "number" ? previewState.placed.farmland : 0;
              const farmlandCost = farmlandPlaced < 4 ? 0 : 25;
              if (previewState.money < farmlandCost) return false;
              previewState.money -= farmlandCost;
              previewState.filledAdds.add(key);
              previewState.placed.farmland = farmlandPlaced + 1;
              return true;
            }
            case "plantCrop": {
              const crop = crops[action.cropKey];
              const stock = stocks[action.stockKey];
              if (!crop || !stock || !crop.unlocked) return false;
              if (getPlot(key) || !getFilled(key)) return false;
              if (typeof crop.limit === "number" && crop.limit >= 0 && previewState.placed[crop.id] >= crop.limit) return false;
              const plantCost = typeof crop.placeCost === "number" ? crop.placeCost : 0;
              if (previewState.money < plantCost) return false;
              previewState.money -= plantCost;
              previewState.placed[crop.id] += 1;
              return true;
            }
            default:
              return false;
          }
        }

        function harvestPlot(key) {
          const plot = world.plots.get(key);
          if (!plot) return;
          const crop = crops[plot.cropKey];
          const stock = stocks[plot.stockKey];
          if (!crop || !stock) return;
          const effectivePrice = plot.lockedStockPrice != null ? plot.lockedStockPrice : stock.price;
          const pctChange = (effectivePrice - plot.stockPriceAtPlant) / plot.stockPriceAtPlant;
          const value = Math.max(0, crop.baseValue * (1 + pctChange));
          world.harvestAnimations.push({ key, value, start: performance.now() });
          if (typeof crop.placed === "number" && crop.placed > 0) crop.placed -= 1;
          state.totalMoney += value;
          onMoneyChanged();
          world.plots.delete(key);
          state.needsRender = true;
          saveState();
        }

        function destroyPlot(key) {
          const plot = world.plots.get(key);
          if (!plot) return;
          const crop = crops[plot.cropKey];
          if (crop && typeof crop.placed === "number" && crop.placed > 0) crop.placed -= 1;
          world.plots.delete(key);
          state.needsRender = true;
          saveState();
        }

        function collectHoeDestroyTargets(baseRow, baseCol) {
          const targets = [];
          const sizeOption = currentSizeOption();
          const size = Math.max(1, sizeOption.size || 1);
          const now = performance.now();
          for (let dr = 0; dr < size; dr++) {
            for (let dc = 0; dc < size; dc++) {
              const row = baseRow + dr;
              const col = baseCol + dc;
              if (row < 0 || col < 0 || row >= config.gridRows || col >= config.gridCols) continue;
              const key = row + "," + col;
              const plot = world.plots.get(key);
              const crop = plot ? crops[plot.cropKey] : null;
              if (plot && crop && now - plot.plantedAt < crop.growTimeMs) targets.push(key);
            }
          }
          return targets;
        }

        function handleTileAction(row, col, action) {
          if (row < 0 || col < 0 || row >= config.gridRows || col >= config.gridCols) return { success: false };
          const key = row + "," + col;
          const resolvedAction = action || determineActionForTile(row, col);
          if (!resolvedAction || resolvedAction.type === "none") return { success: false, reason: resolvedAction ? resolvedAction.reason : undefined };

          switch (resolvedAction.type) {
            case "harvest": {
              const existingPlot = world.plots.get(key);
              if (!existingPlot) return { success: false, reason: "Nothing to harvest" };
              const crop = crops[existingPlot.cropKey];
              if (!crop) return { success: false, reason: "Unknown crop" };
              const elapsed = Date.now() - existingPlot.plantedAt;
              if (elapsed >= crop.growTimeMs) {
                harvestPlot(key);
                return { success: true };
              }
              return { success: false, reason: "Not ready to harvest" };
            }
            case "confirmDestroy": {
              const existingPlot = world.plots.get(key);
              if (!existingPlot) return { success: false, reason: "Nothing to remove" };
              openConfirmModal("Are you sure you want to destroy this crop? No money will be earned.", () => destroyPlot(key), "Destroy Crop");
              return { success: true };
            }
            case "removeFarmland": {
              const hadFarmland = world.filled.delete(key);
              if (hadFarmland && crops.farmland) {
                const f = crops.farmland;
                const previousPlaced = f.placed || 0;
                if (typeof f.placed === "number" && f.placed > 0) f.placed -= 1;
                if (previousPlaced > 4) {
                  state.totalMoney += 25;
                  onMoneyChanged();
                  world.costAnimations.push({ key, value: 25, start: performance.now() });
                }
              }
              state.needsRender = true;
              renderCropOptions();
              saveState();
              return { success: hadFarmland, reason: hadFarmland ? undefined : "No farmland here" };
            }
            case "placeFarmland": {
              const farmlandCrop = crops.farmland;
              if (!farmlandCrop) return { success: false, reason: "Missing farmland crop" };
              if (world.plots.has(key) || world.filled.has(key)) return { success: false, reason: "Tile occupied" };
              const cost = farmlandCrop.placed < 4 ? 0 : 25;
              if (cost > 0) {
                if (state.totalMoney < cost) return { success: false, reason: `Need ${formatCurrency(cost)} to place` };
                state.totalMoney -= cost;
                onMoneyChanged();
                world.costAnimations.push({ key, value: -cost, start: performance.now() });
              }
              world.filled.add(key);
              farmlandCrop.placed += 1;
              state.needsRender = true;
              renderCropOptions();
              saveState();
              return { success: true };
            }
            case "plantCrop": {
              const cropKey = resolvedAction && resolvedAction.cropKey ? resolvedAction.cropKey : state.selectedCropKey;
              const stockKey = resolvedAction && resolvedAction.stockKey ? resolvedAction.stockKey : state.selectedStockKey;
              const crop = crops[cropKey];
              const stock = stocks[stockKey];
              if (!crop || !crop.unlocked) return { success: false, reason: "Crop locked" };
              if (!stock) return { success: false, reason: "Select a stock" };
              if (world.plots.has(key)) return { success: false, reason: "Tile already planted" };
              if (!world.filled.has(key)) return { success: false, reason: "Need farmland first" };
              if (typeof crop.limit === "number" && crop.limit >= 0 && crop.placed >= crop.limit) return { success: false, reason: "Crop limit reached" };
              const plantCost = typeof crop.placeCost === "number" ? crop.placeCost : 0;
              if (plantCost > 0) {
                if (state.totalMoney < plantCost) return { success: false, reason: `Need ${formatCurrency(plantCost)} to plant ${crop.name}` };
                state.totalMoney -= plantCost;
                onMoneyChanged();
                world.costAnimations.push({ key, value: -plantCost, start: performance.now() });
              }
              world.plots.set(key, {
                cropKey,
                stockKey,
                plantedAt: Date.now(),
                stockPriceAtPlant: stock.price,
                lockedStockPrice: null,
                stageBreakpoints: createRandomStageBreakpoints(),
              });
              crop.placed += 1;
              state.needsRender = true;
              saveState();
              return { success: true };
            }
            default:
              return { success: false };
          }
        }

        function handleTap(clientX, clientY) {
          const tile = tileFromClient(clientX, clientY);
          if (!tile) return;
          const sizeOption = currentSizeOption();
          const size = sizeOption.size || 1;
          const baseRow = tile.row;
          const baseCol = tile.col;
          const baseAction = state.hoeSelected ? null : determineActionForTile(baseRow, baseCol);
          let failure = null;
          let hadSuccess = false;
          for (let dr = 0; dr < size; dr++) {
            for (let dc = 0; dc < size; dc++) {
              const row = baseRow + dr;
              const col = baseCol + dc;
              const actionForCell = state.hoeSelected ? determineActionForTile(row, col) : baseAction;
              const result = handleTileAction(row, col, actionForCell);
              if (result.success) {
                hadSuccess = true;
                continue;
              }
              const reason = (actionForCell && actionForCell.reason) || result.reason;
              if (!reason || failure) continue;
              failure = { reason, x: clientX, y: clientY };
            }
          }
          if (!hadSuccess && failure) showActionError(failure.reason, failure.x, failure.y);
        }
        function onPointerDown(e) {
          canvas.setPointerCapture(e.pointerId);
          updatePointer(e);
          if (state.activePointers.size === 2) {
            state.isDragging = false;
            state.isPinching = true;
            const [p1, p2] = getTwoPointers();
            state.pinchStartDistance = Math.hypot(p2.x - p1.x, p2.y - p1.y);
            state.pinchStartScale = state.scale;
            state.pinchCenter = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
            state.tapStart = null;
          } else if (state.activePointers.size === 1) {
            state.isPinching = false;
            state.isDragging = true;
            state.dragStart = { x: e.clientX, y: e.clientY };
            state.dragOffsetStart = { x: state.offsetX, y: state.offsetY };
            state.tapStart = { id: e.pointerId, x: e.clientX, y: e.clientY, time: performance.now() };
            if (state.hoeSelected) {
              const tile = tileFromClient(e.clientX, e.clientY);
              if (tile) {
                const targets = collectHoeDestroyTargets(tile.row, tile.col);
                if (targets.length > 0) {
                  const destroyTargets = targets.slice();
                  state.hoeHoldTimeoutId = setTimeout(() => {
                    state.hoeHoldTimeoutId = null;
                    state.hoeHoldTriggered = true;
                    const count = destroyTargets.length;
                    const label = count === 1 ? "crop" : "crops";
                    openConfirmModal(`Destroy ${count} ${label}? No money will be earned.`, () => destroyTargets.forEach((k) => destroyPlot(k)), count === 1 ? "Destroy Crop" : "Destroy Crops");
                  }, config.hoeDestroyWindowMs);
                }
              }
            }
          }
        }

        function onPointerMove(e) {
          updatePointer(e);
          if (state.isPinching && state.activePointers.size === 2) {
            e.preventDefault();
            const [p1, p2] = getTwoPointers();
            const d = Math.hypot(p2.x - p1.x, p2.y - p1.y);
            if (state.pinchStartDistance > 0) {
              const newScale = clampScale(state.pinchStartScale * (d / state.pinchStartDistance));
              const k = newScale / state.scale;
              state.offsetX = state.pinchCenter.x - (state.pinchCenter.x - state.offsetX) * k;
              state.offsetY = state.pinchCenter.y - (state.pinchCenter.y - state.offsetY) * k;
              state.scale = newScale;
              state.scaleDirty = true;
              state.needsRender = true;
            }
          } else if (state.isDragging) {
            e.preventDefault();
            state.offsetX = state.dragOffsetStart.x + (e.clientX - state.dragStart.x);
            state.offsetY = state.dragOffsetStart.y + (e.clientY - state.dragStart.y);
            state.needsRender = true;
            if (state.tapStart) {
              const dx = e.clientX - state.tapStart.x;
              const dy = e.clientY - state.tapStart.y;
              if (dx * dx + dy * dy > 25) {
                state.tapStart = null;
                if (state.hoeHoldTimeoutId) {
                  clearTimeout(state.hoeHoldTimeoutId);
                  state.hoeHoldTimeoutId = null;
                }
              }
            }
          }
          updateHoverFromEvent(e);
        }

        function onPointerUp(e) {
          if (state.hoeHoldTimeoutId) {
            clearTimeout(state.hoeHoldTimeoutId);
            state.hoeHoldTimeoutId = null;
          }
          state.activePointers.delete(e.pointerId);
          canvas.releasePointerCapture(e.pointerId);
          if (state.activePointers.size < 2) state.isPinching = false;
          if (state.activePointers.size === 0) state.isDragging = false;

          if (state.hoeHoldTriggered) {
            state.hoeHoldTriggered = false;
            state.tapStart = null;
          } else if (state.tapStart && state.tapStart.id === e.pointerId) {
            const dt = performance.now() - state.tapStart.time;
            const dx = e.clientX - state.tapStart.x;
            const dy = e.clientY - state.tapStart.y;
            if (dt < 300 && dx * dx + dy * dy <= 25) handleTap(e.clientX, e.clientY);
          }
          state.tapStart = null;

          if (e.type === "pointerleave" || e.type === "pointercancel") setHoverTile(null);
          else updateHoverFromEvent(e);

          if (state.scaleDirty && state.activePointers.size === 0) {
            saveState();
            state.scaleDirty = false;
          }
        }

        function onWheel(e) {
          e.preventDefault();
          const rect = canvas.getBoundingClientRect();
          const cx = rect.width / 2;
          const cy = rect.height / 2;
          const factor = e.deltaY < 0 ? 1.1 : 1 / 1.1;
          zoomAt(factor, cx, cy);
        }

        function showActionError(message, clientX, clientY) {
          const bubble = document.createElement("div");
          bubble.className = "action-error";
          bubble.textContent = message;
          const clampedX = Math.max(12, Math.min(window.innerWidth - 12, clientX));
          const clampedY = Math.max(12, Math.min(window.innerHeight - 12, clientY - 16));
          bubble.style.left = clampedX + "px";
          bubble.style.top = clampedY + "px";
          document.body.appendChild(bubble);
          setTimeout(() => {
            bubble.style.opacity = "0";
            bubble.style.transition = "opacity 120ms ease";
            setTimeout(() => bubble.remove(), 150);
          }, 1200);
        }

        function openOffcanvas() {
          if (!dom.navOffcanvas || !dom.navOverlay || !dom.navToggle) return;
          dom.navOffcanvas.classList.remove("translate-x-full");
          dom.navOverlay.classList.remove("hidden");
          dom.navToggle.setAttribute("aria-expanded", "true");
        }

        function closeOffcanvas() {
          if (!dom.navOffcanvas || !dom.navOverlay || !dom.navToggle) return;
          dom.navOffcanvas.classList.add("translate-x-full");
          dom.navOverlay.classList.add("hidden");
          dom.navToggle.setAttribute("aria-expanded", "false");
        }

        function toggleOffcanvas() {
          if (!dom.navOffcanvas) return;
          const isClosed = dom.navOffcanvas.classList.contains("translate-x-full");
          if (isClosed) openOffcanvas();
          else closeOffcanvas();
        }

        function closeConfirmModal() {
          if (!dom.confirmModal) return;
          dom.confirmModal.classList.add("hidden");
          document.body.classList.remove("overflow-hidden");
          pendingConfirmAction = null;
        }

        function openConfirmModal(message, onConfirm, title = "Confirm") {
          if (!dom.confirmModal || !dom.confirmMessage || !dom.confirmConfirm || !dom.confirmCancel) {
            onConfirm();
            return;
          }
          if (dom.confirmTitle) dom.confirmTitle.textContent = title;
          dom.confirmMessage.textContent = message;
          pendingConfirmAction = onConfirm;
          dom.confirmModal.classList.remove("hidden");
          document.body.classList.add("overflow-hidden");
          dom.confirmConfirm.focus();
        }

        function updateStatsToggleUI() {
          if (!dom.toggleStatsBtn) return;
          dom.toggleStatsBtn.textContent = "Show Stats";
          dom.toggleStatsBtn.classList.toggle("bg-emerald-600", state.showStats);
          dom.toggleStatsBtn.classList.toggle("text-white", state.showStats);
          dom.toggleStatsBtn.classList.toggle("border-emerald-500", state.showStats);
          dom.toggleStatsBtn.classList.toggle("bg-neutral-800", !state.showStats);
          dom.toggleStatsBtn.classList.toggle("text-neutral-200", !state.showStats);
          dom.toggleStatsBtn.classList.toggle("border-neutral-600", !state.showStats);
        }

        function updateModeButtonsUI() {
          const plantingMode = !state.hoeSelected;
          if (dom.hoeButton) {
            dom.hoeButton.classList.toggle("border-emerald-500", state.hoeSelected);
            dom.hoeButton.classList.toggle("border-neutral-700", !state.hoeSelected);
            dom.hoeButton.classList.remove("bg-emerald-500/10");
            dom.hoeButton.setAttribute("aria-pressed", state.hoeSelected ? "true" : "false");
          }
          if (dom.cropStockButton) {
            dom.cropStockButton.classList.toggle("border-emerald-500", plantingMode);
            dom.cropStockButton.classList.toggle("border-neutral-700", !plantingMode);
          }
        }

        function updateCropStockButtonUI() {
          if (!dom.cropStockButton) return;
          const crop = state.selectedCropKey ? crops[state.selectedCropKey] : null;
          const stock = stocks[state.selectedStockKey];
          const src = cropImageSrc(crop ? crop.id : null);
          if (dom.cropStockImage) {
            dom.cropStockImage.src = src;
            dom.cropStockImage.alt = crop ? crop.name : "Crop";
          }
          const stockText = stock ? stock.symbol : "";
          if (dom.cropStockStockLabel) {
            dom.cropStockStockLabel.textContent = stockText;
            const len = stockText.length || 1;
            const fontSize = len > 6 ? 8 : len > 4 ? 9 : 11;
            dom.cropStockStockLabel.style.fontSize = fontSize + "px";
          }
          if (dom.cropStockStockWrapper) {
            const hideStock = crop && (crop.id === "grass" || crop.id === "farmland");
            dom.cropStockStockWrapper.classList.toggle("hidden", hideStock);
          }
        }

        function updateSizeButtonUI() {
          if (!dom.sizeButton) return;
          const size = currentSizeOption();
          if (dom.sizeButtonLabel) dom.sizeButtonLabel.textContent = size ? size.name : "";
        }

        function renderSizeMenu() {
          if (!dom.sizeMenu) return;
          dom.sizeMenu.innerHTML = "";
          Object.values(sizes).forEach((size) => {
            const locked = !size.unlocked;
            const btn = document.createElement("button");
            btn.type = "button";
            btn.className = "w-full px-3 py-2 text-left text-[11px] font-semibold border-b border-neutral-800 last:border-b-0 flex items-center justify-between";
            if (!locked) btn.classList.add("hover:bg-neutral-800");
            btn.textContent = size.name;
            if (size.id === state.selectedSizeKey) {
              btn.classList.add("text-emerald-400");
            } else {
              btn.classList.add(locked ? "text-neutral-600" : "text-neutral-100");
            }
            let unlockCostEl = null;
            if (locked && typeof size.unlockCost === "number") {
              unlockCostEl = document.createElement("span");
              unlockCostEl.textContent = `Unlock: ${formatCurrency(size.unlockCost)}`;
              unlockCostEl.className = "text-[10px] font-normal";
              btn.appendChild(unlockCostEl);
            }
            const canAffordUnlock = locked && typeof size.unlockCost === "number" && state.totalMoney >= size.unlockCost;
            btn.disabled = locked && !canAffordUnlock;
            if (unlockCostEl) {
              unlockCostEl.classList.toggle("text-amber-300", canAffordUnlock);
              unlockCostEl.classList.toggle("text-neutral-600", !canAffordUnlock);
            }
            btn.addEventListener("click", () => {
              if (locked) {
                if (!canAffordUnlock) return;
                openConfirmModal(
                  `Unlock ${size.name} for ${formatCurrency(size.unlockCost)}?`,
                  () => {
                    state.totalMoney -= size.unlockCost;
                    size.unlocked = true;
                    state.selectedSizeKey = size.id;
                    onMoneyChanged();
                    renderSizeMenu();
                    updateSizeButtonUI();
                    state.needsRender = true;
                    saveState();
                    if (dom.sizeMenu) dom.sizeMenu.classList.add("hidden");
                    sizeMenuVisible = false;
                  },
                  "Confirm Unlock"
                );
                return;
              }
              state.selectedSizeKey = size.id;
              renderSizeMenu();
              updateSizeButtonUI();
              state.needsRender = true;
              saveState();
              dom.sizeMenu.classList.add("hidden");
              sizeMenuVisible = false;
            });
            dom.sizeMenu.appendChild(btn);
          });
        }

        function closeSizeMenu() {
          if (!dom.sizeMenu) return;
          dom.sizeMenu.classList.add("hidden");
          sizeMenuVisible = false;
        }

        function renderCropOptions() {
          if (!dom.cropGrid) return;
          dom.cropGrid.innerHTML = "";
          Object.values(crops).forEach((crop) => {
            const card = document.createElement("button");
            card.type = "button";
            const canAffordUnlock = !crop.unlocked && typeof crop.unlockCost === "number" && crop.unlockCost > 0 && state.totalMoney >= crop.unlockCost;
            let baseClass = "relative w-full aspect-square rounded-md overflow-hidden border text-left bg-neutral-900";
            if (crop.id === state.selectedCropKey) baseClass += " border-emerald-500 ring-1 ring-emerald-500";
            else if (!crop.unlocked && canAffordUnlock) baseClass += " border-amber-400/60 hover:border-amber-300";
            else baseClass += " border-neutral-700 hover:border-neutral-500";
            if (!crop.unlocked) {
              baseClass += " cursor-pointer";
              if (!canAffordUnlock) baseClass += " opacity-40";
            } else {
              baseClass += " cursor-pointer";
            }
            card.className = baseClass;

            const img = document.createElement("img");
            if (crop.id === "grass") img.src = "images/grass.jpg";
            else if (crop.id === "farmland") img.src = "images/farmland.jpg";
            else img.src = `images/${crop.id}/${crop.id}-phase-4.png`;
            img.alt = crop.name;
            img.className = "absolute inset-0 w-full h-full object-cover";
            if (!crop.unlocked && !canAffordUnlock) img.className += " grayscale";
            card.appendChild(img);

            const overlay = document.createElement("div");
            overlay.className = "relative z-10 h-full flex flex-col justify-end bg-gradient-to-t from-black/85 via-black/50 to-transparent p-2 text-[10px] space-y-0.5";
            if (crop.id === "grass") {
              overlay.innerHTML = `<div class="font-semibold text-xs text-white">${crop.name}</div><div class="text-neutral-200">Cost: Free</div>`;
            } else if (crop.id === "farmland") {
              const nextCost = crop.placed < 4 ? 0 : 25;
              const costText = nextCost === 0 ? "Cost: Free" : `Cost: ${formatCurrency(nextCost)}`;
              overlay.innerHTML = `<div class="font-semibold text-xs text-white">${crop.name}</div><div class="text-neutral-200">${costText}</div>`;
            } else {
              const plantCost = typeof crop.placeCost === "number" ? crop.placeCost : 0;
              const costText = plantCost > 0 ? formatCurrency(plantCost) : "Free";
              const sellText = formatCurrency(crop.baseValue);
              overlay.innerHTML =
                `<div class="font-semibold text-xs text-white">${crop.name}</div>` +
                `<div class="text-neutral-200">Cost: ${costText}</div>` +
                `<div class="text-neutral-200">Sell: ${sellText}</div>` +
                `<div class="text-neutral-300">Time: ${crop.growMinutes} min</div>`;
              if (!crop.unlocked && crop.unlockCost > 0) {
                overlay.innerHTML += `<div class="text-[9px] font-normal text-amber-300 mt-1">Unlock: ${formatCurrency(crop.unlockCost)}</div>`;
              }
            }
            card.appendChild(overlay);

            card.addEventListener("click", () => {
              if (!crop.unlocked) {
                if (crop.unlockCost > 0 && state.totalMoney >= crop.unlockCost) {
                  openConfirmModal(
                    `Unlock ${crop.name} for ${formatCurrency(crop.unlockCost)}?`,
                    () => {
                      state.totalMoney -= crop.unlockCost;
                      crop.unlocked = true;
                      state.selectedCropKey = crop.id;
                      state.previousCropKey = crop.id;
                      onMoneyChanged();
                      updateCropStockButtonUI();
                      saveState();
                    },
                    "Confirm Unlock"
                  );
                }
                return;
              }
              state.selectedCropKey = crop.id;
              state.previousCropKey = crop.id;
              renderCropOptions();
              updateCropStockButtonUI();
              saveState();
            });

            dom.cropGrid.appendChild(card);
          });
        }

        function renderStockOptions() {
          if (!dom.stockGrid) return;
          dom.stockGrid.innerHTML = "";
          Object.values(stocks).forEach((stock) => {
            const btn = document.createElement("button");
            btn.type = "button";
            let cls = "w-full aspect-square rounded-md border flex items-center justify-center text-[11px] font-semibold tracking-wide";
            if (stock.symbol === state.selectedStockKey) cls += " border-emerald-500 bg-emerald-500/10";
            else cls += " border-neutral-700 bg-neutral-900 hover:bg-neutral-800";
            btn.className = cls;
            btn.textContent = stock.symbol;
            btn.addEventListener("click", () => {
              state.selectedStockKey = stock.symbol;
              renderStockOptions();
              updateCropStockButtonUI();
              saveState();
            });
            dom.stockGrid.appendChild(btn);
          });
        }

        function updateStockPrices() {
          Object.values(stocks).forEach((s) => {
            const factor = 1 + (Math.random() - 0.5) * 0.01;
            s.price = Math.max(1, s.price * factor);
          });
          state.needsRender = true;
        }

        function resetFarm() {
          try {
            localStorage.clear();
          } catch (err) {
            console.error("Failed to clear storage", err);
          }
          window.location.reload();
        }
      })();
    </script>
  </body>
</html>
